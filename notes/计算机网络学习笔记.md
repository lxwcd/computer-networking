计算机网络学习笔记

# 学习资源

## 书籍
> 小白入门计算机网络知识：计算机网络 谢希仁 第 7 版
> 看完 计算机网络 后可以补充看：图解TCP_IP
> linux 上学习网络工具，实操：鸟哥的Linux私房菜服务器架设篇
> 对计算机基础网络知识有一定了解后看，提到很多概论，拓展知识：趣谈网络协议 刘超 



## 视频
> [PowerCertAnimatedVideos](https://www.youtube.com/@PowerCertAnimatedVideos)


## 学习过程
1. 学习计算机网络基础知识
- 看谢希仁的**计算机网络（第 7 版）** 前 7 章，了解计算机网络基础知识
- 快速看**图解TCP_IP（第 5 版）**，作为查漏补缺
- 鸟哥的Linux私房菜服务器架设篇，学习 linux 中网络工具使用


# 计算机网络基础知识
主要笔记在**计算机网络**和**图解TCP_IP**两本书的笔记中，这里做一些零碎补充

## LAN WAN SUBNET
> [LAN, WAN, SUBNET - EXPLAINED](https://www.youtube.com/watch?v=NyZWSvSj8ek&ab_channel=PowerCertAnimatedVideos)


## 计算机网络体系分层的目的
> [计算机网络为什么要分层](https://www.cnblogs.com/ricklz/p/16457713.html)
> 计算机网络 谢希仁 第7版 1.7

相互通信的计算机必须协调工作，而这种协调十分复杂，分层可以将复杂的问题转换为若干较小的局部问题

分层的好处如下：
- 各层之间独立
每一层不用关心其他层如何实现，仅需知道层间接口所提供的服务
下层对上层透明

- 灵活性好
任意一层发生发生变化，只要层间接口不变，不影响其他层

- 结构上可分割开
各层可以采用最适合自己的技术实现

- 易于实现和维护
不用调试一个十分庞大而复杂的系统，因为每层为一个相对独立的子系统

- 促进标准化工作
每层有自己明确的功能，且有精确说明


分层的缺点：
- 可能有些功能在不同层重复出现而产生额外开销


计算机网络的各层及其协议的集合就是网络的体系结构 (architecture)
计算机的体系结构就是计算机网络及其构件所应完成的功能的精确定义
体系结构是抽象的，其实现靠具体的硬件和软件

## 透明
在计算机网络中，"透明"是一个重要的概念，表示某个组件或系统对于其他组件或系统来说是不可见的，或者说对其他组件的行为没有显著的影响。

以下是几个计算机网络中"透明"概念的例子：

1. 物理层对数据链路层透明：物理层尽可能**屏蔽掉传输媒体和通信手段的差异，使物理层上层的数据链路层感觉不到这些差异**，只用考虑如何完成本层的协议和服务。

2. 传输层透明：在网络通信中，传输层的透明性是指对于应用层来说，传输层提供的传输服务是无差别的，无论底层网络使用的是哪种技术或协议。例如，TCP协议在底层可以使用以太网、Wi-Fi或者其他网络技术实现，但应用程序不需要关心底层的具体实现细节，只需使用统一的套接字接口进行数据的发送和接收。

3. 路由器透明：在计算机网络中，路由器是负责将数据包从源地址转发到目标地址的网络设备。路由器的透明性意味着它在转发数据包时不会对数据内容进行修改或解析。无论是文本、图像还是视频数据，路由器都会透明地将它们传递到下一个网络节点，而不会对数据包本身产生任何影响。

4. 隧道透明：隧道是一种将一个协议的数据封装在另一个协议的数据包中进行传输的方式。隧道协议的透明性表明，封装在隧道中的数据将在传输过程中被保持原样，不会被修改或解析。这样，隧道的两端可以是不同网络或不同协议的设备，但它们仍然可以通过隧道进行通信。

5. 加密透明：加密透明是指在网络通信中使用加密技术时，对于通信的两端来说，使用加密算法进行数据加密和解密是透明的。通信的两端可以像使用非加密通信一样发送和接收数据，中间的加密和解密过程对它们是透明的。这为安全的网络通信提供了便利，同时确保了用户数据的隐私和保密性。

这些例子展示了计算机网络中的"透明"概念，即某个组件或系统的行为对其他组件来说是不可见的。透明性帮助网络中的各个组件相互协作，并简化了网络通信和管理的复杂性。


## 五层协议
OSI 七层协议
- 物理层，数据链路层，网络层，运输层，会话层，表示层，应用层
- 理论模型

TCP/IP 四层协议
- 网络接口层，网际层，运输层，应用层
- 实际使用

五层协议划分
- 物理层，数据链路层，网络层，运输层，应用层

### 物理层
- physical layer
- 传输的数据单位为比特，考虑的是用多大电压表示 1 和 0 以及接收方如何识别发送的比特（编码方式等）
- 物理层还要考虑与传输媒介，如双绞线等接口的一些特性，但具体传输媒介的特性不属于物理层，是在物理层之下
- 物理层尽可能**屏蔽掉传输媒体和通信手段的差异，使物理层上层的数据链路层感觉不到这些差异**，只用考虑如何完成本层的协议和服务

### 数据链路层
- data link layer

数据链路层要解决的三个问题：
- 封装成帧 (framing)
帧的首部和尾部用于帧定界，且包括许多必要的控制信息，发送帧时从帧的首部开始发送。
数据链路层协议对帧首部和帧尾部的格式有明确的规定，也规定了帧的数据部分长度上限，即最大传输单元 **MTU** （Maximum Transfer Unit）。不同数据链路的 MTU 不同。

- 透明传输 
无论什么比特组合的数据，都能按照原样没有差错的通过数据链路层，即数据链路层对这些数据透明
传输的数据不会因为帧定界的方式与数据的来源不兼容而出现错误

- 差错检测
数据链路层将数据封装成帧中包含数据和控制信息，控制信息中含有差错控制，发现差错则丢弃帧
数据链路层使用 CRC 检验，能实现无比特差错的传输，但不是可靠传输，即数据链路层不会检验帧丢失，帧重复或帧失序等差错

对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不向上层提供可靠的传输服务
对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，即不向上层提供可靠的传输服务

### 网络层
- network layer

将运输层产生的报文段或用户数据报封装成分组或包传送给分组交换网上的不同主机
选择合适的路由使得源主机的数据包能到达目的主机

### 运输层
- transport layer

运输层负责向两台主机中进程之间的通信提供通用的数据传输服务，通用指多个应用能使用一个运输层服务

运输层有复用和分用的功能，复用表示多个应用层进程同时使用运输层的服务，
分用表示运输层将收到的信息分别交付给应用层中的相应进程

运输层向高层用户屏蔽下面网络核心的细节（如网络拓扑、所采用的路由协议等），使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。

### 应用层
- application layer

应用层通过应用进程间的交互来完成特定网络应用
应用层协议定义应用进程间通信和交互的规则

## 三层网络模型
> [Build Your Skills: The three-layer hierarchical model](https://www.techrepublic.com/article/build-your-skills-the-three-layer-hierarchical-model/)
> [3 Layer Cisco Hierarchical Model](https://ipwithease.com/3-layer-cisco-hierarchical-model/)
> [Three-Layer Hierarchical Model in Cisco](https://www.geeksforgeeks.org/three-layer-hierarchical-model-in-cisco/)
> [Network Topology Architectures (2-tier and 3-tier) | Cisco CCNA 200-301](https://www.youtube.com/watch?v=XHlr791Lid0&ab_channel=KeithBarker-TheOGofIT)
> [CCNA Training CBT - Cisco Three Layer Hierarchical Model](https://www.youtube.com/watch?v=vCneK-9nVyI&ab_channel=ITdvds)


- 接入层（access layer）
    - 连接终端到局域网中，如 VLAN 在接入层分开广播域，或者路由器划分的子网。
    - use switches or hubs

- 分发层（distribution layer）
    - 也叫汇聚层，如连接接入层不同的 VLAN，或者接入层不同的子网；如果接入层划分不同子网，分发层连接不同的子网，这些子网仍然属于一个局域网，分发层的路由器有一个路由表用来过滤数据包决定分发给哪个子网。
    - 例如防火墙，NAT 配置等在分发层。
    - use routers to connect multiple networks together

- 核心层（core layer）
    - 复杂高速数据转发，连接分发层的各个设备。


## 集线器 Hub
- 工作在物理层，仅简单地转发比特，半双工通信
- 不进行碰撞检测，因此有 CSMA/CD 协议，保证同一时刻只有一个站点发送数据

## 以太网交换机 switch
- 工作在数据链路层，全双工通信，能隔离冲突域
- 以太网交换机实质是多接口网桥，网桥只有两个接口，以太网交换机接口更多。
- 以太网交换机使用了专门的交换结构芯片，用硬件转发，其转发速率比普通网桥快。
- 以太网交换机有存储器，能进行帧缓存。
- 以太网交换机内有交换表，能进行自学习，交换表中每个条目是每个端口号以及对应的 MAC 地址，交换表有一定的有效时间，过期就删除。
- 以太网交换机是即插即用设备，因为其自有自学习能力，不必人工配置。
- 以太网交换机一般有多种速率接口。 
- 以太网交换机大多数对帧采用存储转发的方式，但也有些采用直通方式交换，直通交换不进行差错检测就将帧发出去。
- 以太网是全双工通信方式。



## 广播域与冲突域
> [Broadcast Domains and Collision Domains - CompTIA Network+ N10-007 - 1.3](https://www.youtube.com/watch?v=SGbtLjIEVeo&ab_channel=ProfessorMesser)
> [CSMA/CD and CSMA/CA Explained](https://www.youtube.com/watch?v=iKn0GzF5-IU&t=103s&ab_channel=PowerCertAnimatedVideos)

- broadcast domain and collision domain

### collision domain
在以太网中，当两个设备同时将数据包发送到同一物理链路上时，这些数据包可能会在传输过程中发生碰撞，导致数据包损坏。
这是因为以太网使用的是半双工通信方式，设备不能同时发送和接收数据。
碰撞域的存在会限制网络的传输效率和可靠性。


- hub 连接的主机为一个 collision domain
- 同一时刻最多只允许一个站点发送数据
- 各主机的网络适配器执行 CSMA/CD 协议以避免冲突
- switch 能隔离冲突域，switch 是全双工通信，且有存储器能对数据进行缓存

### broadcast domain
广播域是指网络中的一组设备，当其中一个设备发送广播消息时，其他设备都能够接收到该消息
广播是一种发送到本地网络上的特殊数据包，其目标地址为广播地址，例如IPv4中的255.255.255.255

- 第二层以太网交换机所连接的设备属于一个广播域
- ARP 广播会在一个广播域中传输
- VLAN 可以隔离广播域
- 路由器可以隔离广播域

## 网络环路和生成树协议 STP
查看 **趣谈网络协议 2.2 节**的讲解


## VLAN 
> [VLAN Explained](https://www.youtube.com/watch?v=jC6MJTh9fRE&ab_channel=PowerCertAnimatedVideos)

- 从逻辑上划分广播域，限制接收广播风暴的计算机数量
- 工作在数据链路层
- 在以太网帧中加入一个 VLAN 标志，占 4 字节，但实际可分配的主机数只有 12 位，即 4096 个主机
- 对交换机有要求
- 二层的交换机只能在一个局域网中划分广播域

## IP 地址和 MAC 地址的区别
> [MAC Address Explained](https://www.youtube.com/watch?v=TIiQiw7fpsU&ab_channel=PowerCertAnimatedVideos)


![](https://img-blog.csdnimg.cn/23b18ee986bb4b04a797e4740fac3195.png)
![](https://img-blog.csdnimg.cn/cb17f7e950c64d7ca660ecb403d4c264.png)


- 在 IP 层抽象的互联网上只能看到 IP 数据报，屏蔽了下层网络硬件地址体系的不同等复杂细节。
- 互联网可以由很多[异构网](https://en.wikipedia.org/wiki/Heterogeneous_network)组成，使用 IP 协议让互联网上的主机好像在一个单个网络上通信，而不用管各网络的具体异构细节。
- IP 数据报首部的源地址和目的地址始终不变，是最终的源和目的地址
- 路由器进行路由是依据 IP 地址，IP 地址更有规律，适合路由器进行路由管理
- IP 地址是软件实现的逻辑地址，很容易变化；物理地址是硬件地址，在网络适配器的 ROM 中，一般不会变化
- 局域网的数据链路层只能看见 MAC 帧，以太网交换机的交换表是根据 MAC 地址进行转发
- MAC 帧经过不同的网络时，其帧首部的源地址和目的地址都要变化，源地址变为当前发送的地址，目的地址下一跳的地址


## 子网（subnet）和 虚拟局域网 VLAN 区别
> [LAN, WAN, SUBNET - EXPLAINED](https://www.youtube.com/watch?v=NyZWSvSj8ek&list=LL&index=5&ab_channel=PowerCertAnimatedVideos)
> [VLAN Explained](https://www.youtube.com/watch?v=jC6MJTh9fRE&t=1s&ab_channel=PowerCertAnimatedVideos)
> [Subnets vs VLANs](https://www.youtube.com/watch?v=6_giEv20En0&list=LL&index=6&ab_channel=PowerCertAnimatedVideos)


- 划分子网是在网络层，通过路由器划分，不同的子网仍属于一个局域网（LAN）。
- 子网是对 IP 地址的主机号分出一些位数作为子网号
- VLAN 是在数据链路层划分，通过以太网交换机，在 MAC 地址中增加一个标志位来区分，逻辑上划分为多个广播域，但多个广播域仍然在一个局域网中。
- 子网是在物理上划分，VLAN 是在逻辑上划分，都是分割不同的广播域。
- 子网和 VLAN 划分均在访问层（access layer），但连接不同的 VALN 和子网则是在 distribution layer。
- 可能有些场景不能使用 VLAN，只能在网络层划分子网。

## TCP 和 UDP 的区别
1. TCP 是面向连接的，UDP 面向无连接
- 面向连接指互相通信前先建立连接
- TCP 进行三次握手来建立连接，而 UDP 不建立连接
TCP 建立连接的原因：
1) 确保双方都准备好进行通信：在建立TCP连接之前，客户端和服务器需要确保双方都已经准备好进行通信。通过三次握手，客户端和服务器可以确保彼此都处于可达状态，并且可以正常地发送和接收数据。

2) 同步序列号 (Synchronize Sequence Numbers)：在三次握手过程中，服务端和客户端将交换彼此的初始序列号（ISN），以确保双方建立起相同的初始序列号。

序列号用于对TCP数据包进行排序和重组。在建立连接时同步序列号非常重要，因为它们用于标识每个TCP连接中的数据包顺序，并帮助检测和处理重复或丢失的数据包。

3) 确认连接请求和响应：通过三次握手，客户端向服务器发送一个连接请求报文段（SYN），表示客户端希望建立连接。 服务器收到请求后，会回复一个确认报文段（SYN-ACK），以确认收到连接请求，并表示服务器也准备好建立连接。最后，客户端再次回复一个确认报文段（ACK），表示已经接收到服务器的确认，并且连接已经建立。

这样来回的确认过程可以防止服务器收到多个重复的连接请求，以及客户端在发送请求后一段时间后便关闭的情况。通过三次握手，确保连接的可靠性和可用性。

2. TCP 不支持广播或多播通信，UDP 可以一对多或多对多等通信
TCP 需要建立连接，数据传送结束要释放连接，因此不支持一对多
UDP 是无连接的，因此可以进行一对多通信

3. TCP 是面向字节流的，UDP 是面向报文的
应用程序交付给 TCP 的是数据块，但 TCP 将其仅看成一连串无结构的字节流，字节流中的每个字节都被按序编号
TCP 连接的连接的两端有发送缓存和接收缓存，提供全双工通信，不关心应用程序一次将多长的报文发送到 TCP 缓存中，
TCP 是根据对方给出的窗口值和当前网络的拥塞程度决定发送多少字节

UDP 对应用层交付的报文不合并也不拆分，添加首部数据后就交给 IP 层，因此应用层最好选择合适大小的报文，
如果报文太长，到 IP 层后需要分片，会降低 IP 层的效率
报文太短也会降低 IP 层的效率

4. TCP 提供可靠交付，UDP 不保证可靠交付
TCP 是有状态的服务，会跟踪数据包发送状态，而 UDP 是无状态的，不管数据是否发送成功或者有无差错等

TCP 能提供可靠传输的原因：
- 面向连接 Connection-oriented
TCP 在通信前进行三次握手和通信结束后四次挥手保证数据的完整交换

- 确认和重传机制
接收方收到数据后会发送 acknowledgments (ACK) 给发送方以告知对方自己收到数据
如果发送方在一定时间内没有收到 ACK 确认消息，则重传数据包
该机制确保数据不丢失

- 为每个字节分配序号
TCP 在建立连接时会发送初始序号 (sequence number)，此后传输数据的包会依序编号，接收方在发送确认消息时也会指明下次发送的序号
接收方根据序号重组数据，保证数据无差错，按序到达

- 流量控制（flow control）
TCP 利用滑动窗口机制让发送方的发送速率不要太快，以便接收方来得及接收

- 拥塞控制（Congestion control）
TCP 通过监控网络拥塞程度来避免过多的数据注入到网络中，使网络中的路由器或链路不至于过载而影响通信


## TCP 流量控制和拥塞控制的区别

## **流量控制**
![](https://img-blog.csdnimg.cn/8c82283d045f4a3292add077cbbb7f0d.png)
![](https://img-blog.csdnimg.cn/9e02ada12cd04c63b0071a76ccd27f46.png)

流量控制是TCP中的一种机制，用于控制发送方向接收方发送数据的速率，以确保接收方能够及时处理接收到的数据，并防止发送方发送速度过快而导致数据丢失或溢出。
TCP使用滑动窗口机制来进行流量控制。

滑动窗口机制由发送窗口和接收窗口组成。发送窗口是发送方允许发送的字节数量的上限，而接收窗口是接收方能够接收的字节数量的上限。
接收方通过在TCP报文段中的确认号来通知发送方自己的接收窗口大小。
发送方根据接收窗口的大小调整自己发送数据的速率，确保不超过接收方的处理能力。

## **拥塞控制**
![](https://img-blog.csdnimg.cn/57abfeb6440e4ddebb4adab851a0ffc4.png)

拥塞控制是TCP中的另一种机制，用于控制数据在网络中的传输速率，以避免网络拥塞并保持网络的稳定性。
拥塞控制通过监视网络的负载情况和网络的拥塞程度来调整数据的发送速率。

TCP使用一种称为拥塞窗口的方法来实现拥塞控制。拥塞窗口是发送方发送数据的速率与网络负载情况的折中值。
发送方根据网络的拥塞情况动态调整拥塞窗口的大小，以控制数据的发送速率。
拥塞控制算法通常包括慢启动、拥塞避免和快速恢复等阶段，以逐步增加发送速率并对网络拥塞做出响应。

## **拥塞控制与流量控制区别**
![](https://img-blog.csdnimg.cn/05ab7a696a424376a3c7e55c32462712.png)

1. 流量控制是为了确保接收方能够有效地接收数据并避免数据丢失或溢出，而拥塞控制是为了保持网络的稳定性和避免拥塞发生。
2. 流量控制是在发送方和接收方之间进行的，而拥塞控制是在整个网络中进行的。
3. 流量控制是根据接收方的处理能力来控制发送速率，而拥塞控制是根据网络的负载情况和拥塞程度来调整发送速率。
4. 流量控制使用滑动窗口机制来控制发送速率，而拥塞控制使用拥塞窗口算法来调整发送速率。

总的来说，流量控制是为了适应接收方的处理能力调整数据发送速率，而拥塞控制是为了避免网络拥塞并保持网络稳定性调整数据发送速率。它们是TCP协议中的两种重要机制，同时工作来确保传输的可靠性和效率。

## TCP 三报文握手
> [What is a Three-way handshake in TCP?](https://www.youtube.com/watch?v=LyDqA-dAPW4&ab_channel=Cisco)

A 客户端向 B 服务器建立连接：
1. B 服务器需要创建传输控制模块 TCB，开启端口，准备接收客户端进程的连接请求，此时服务器进程处于 LISTEN 状态

2. A 客户端进程也创建传输控制模块 TCB

3. A 向 B 发出连接请求报文，此时首部 SYN 为 1，不能携带数据，但需要消耗一个序号，此时客户进程进入 SYN-SENT 状态

4. B 收到请求报文段后，如同意建立连接，则向 A 发送确认，SYN = 1，ACK =1，返回一个确认号，选择一个初始序号，
   该报文也不能携带数据，但需要消耗一个序号，此时 B 进程进入 SYN-RECD 状态
   
5. A 进程收到 B 确认后，还需向 B 发送确认，确认报文段的 ACK=1，可以携带数据，如果不携带数据，则不消耗序号，
   此时 A 进入 ESTABLISHED 状态

6. B 收到 A 的确认后即进入 ESTABLISHED 状态

## 四报文握手
- 如果 B 发送给 A 确认时分开为两个报文段，即先发一个 ACK = 1 的确认报文段，再发一个 SYN = 1 的同步报文段，
  则变成**四报文握手**

## 建立连接需要三报文的原因

1. A 收到 B 的确认报文后还需要向 B 发送确认
- 防止已失效的连接请求又传到 B，从而产生错误 
如 A 发送连接请求的报文在网络中长时间滞留，因此 A 重新发送连接请求并与 B 建立连接，最后完成释放连接，
B 在与 A 释放连接后，又收到之前 A 发送的连接请求，以为是一次新的连接而向 A 发送确认报文段，
如果没有第三次 A 的确认报文，则连接已建立成功，而 B 会一直等待 A 发送数据，从而造成资源浪费。


*********************

> [2.4.2 TCP 的三向交握](http://cn.linux.vbird.org/linux_server/0110network_basic_4.php#tcpip_transfer_tcphand)


## TCP 四报文挥手
> [TCP-4-times-close](https://wiki.wireshark.org/TCP-4-times-close.md)

- 通信双方都可以释放连接

假设 A 进程向 B 发送连接释放报文段：
1. A 发送连接释放报文段，FIN=1，序号 seq = u (前一次发送数据的最后一个字节序号+1)，
   此后 A 停止发送数据，主动关闭 TCP 连接，A 进入 FIN-WAIT-1 状态;
   A 发送的报文段可以不携带数据，但必须消耗一个序号

2. B 发送确认，ACK=1，B 进入 CLOSE-WAIT 状态

3. 此时 TCP 连接处于**半关闭**状态，即 A 以及完成数据传输，B 仍可以发送数据，A 仍要接收

4. A 收到 B 的确认报文段后进入 FIN-WAIT-2 状态，等待 B 发送连接释放报文段

5. B 可以向 A 继续发送数据，直到没有数据传输，则发出连接释放报文段，FIN=1，ACK=1，
   以及确认号和序号，B 进入 LAST-CHECK 状态，等待 A 的确认

6. A 收到连接释放报文段后，对 B 发出确认，ACK=1，附带确认号和序号，进入 TIME-WAIT 状态，

7. 此时 TCP 连接并未释放，需要**时间等待计时器（TIME-WAIT timer）**设置的时间 2MSL 后，A 才进入 CLOSED 状态。


## TIME-WAIT 阶段的作用
> [Why does TIME_WAIT exist?](https://serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html#why-does-time_wait-exist)


> The MSL is the maximum amount of time that any segment, 
> for all intents and purposes a datagram that forms part of the TCP protocol, 
> can remain valid on the network before being discarded.


TIME-WAIT 阶段，A 等待 2MSL（最长报文段寿命，Maximum Segment Lifetime）的时间

MSL 和 IP 数据报首部的 TTL 字段有关，TTL 限制了该数据报在网络中的存活时间，超过时间即被丢弃

1. The first is to prevent delayed segments from one connection being misinterpreted as being part of a subsequent connection. 
Any segments that arrive whilst a connection is in the 2MSL wait state are discarded.

设置 2MSL 可以保证本连接中之前的已失效的报文段从网络中消失，以防止干扰下次新的连接

2. 确保 A 发送的最后一个 ACK 确认报文段能到达 B，如果该报文丢失，B 会超时重传报文，
A 就能在 2MSL 时间内重新发送最后的确认报文；A 重新发送确认报文后，重新开启了2MSL 计时器。


查看 TIME-WAIT 的时间
```bash
[20:09:49 root@ubuntu2004 ~]# sysctl net.ipv4.tcp_fin_timeout
net.ipv4.tcp_fin_timeout = 60
```

## TCP 保活计时器（Keepalive timer）
- 防止已建立连接后，客户端出现故障，服务端不用一直等待。
- 服务端收到一次客户端的数据，就重置保活计时器，时间通常 2 小时。
- 如果服务端在两小时内没有收到客户端数据，则发送一个探测报文段，
  以后每 75 秒发送一次，若连接发送 10 个探测报文段后无响应，
  则服务端认为客户端出现故障，关闭此连接。


## TCP 的 11 种有限状态机
> [TCP State Transition Diagram](https://flylib.com/books/en/3.223.1.188/1/)

- 为了更清楚看出 TCP 连接的各种状态之间的关系
- ubuntu22.04 中 `man netstat` 可以查看 `state` 状态

# 查看启动方式是 BIOS 还是 UEFI
> [Guide To Check UEFI or BIOS In Windows/Linux System](https://servonode.com/check-uefi-or-bios-in-widows-or-linux)

## 方法一：查看 /sys/firmware/efi 目录

`/sys/firmware/efi` 目录存在则为 UEFI 启动

- ubuntu20.04 UEFI 启动
```bash
[10:17:49 root@ubuntu2004 /sys/firmware]#ls
acpi  dmi  efi  memmap
[10:17:50 root@ubuntu2004 /sys/firmware]#
```

- rocky8.6 BIOS 启动
```bash
root@rocky86 ~ $ cd /sys/firmware/
root@rocky86 firmware $ ls
acpi  dmi  memmap  qemu_fw_cfg
```

## 方法二：dmesg

- ubuntu20.04 UEFI 启动
```bash
root@ubuntu2004 ~# dmesg | grep efi:
[    0.000000] efi: EFI v2.60 by HUAWEI
[    0.000000] efi:  ACPI 2.0=0x8f7fe014  SMBIOS=0x8c4ed000  SMBIOS 3.0=0x8c4eb000  ESRT=0x8c4e9c18  MEMATTR=0x88fd9018  MOKvar=0x88fd7000 
```

- rocky8.6 BIOS 启动
```bash
root@rocky86 firmware $ dmesg | grep efi
[    0.000000] clocksource: refined-jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1910969940391419 ns
[    5.408252] tsc: Refined TSC clocksource calibration: 2918.420 MHz
root@rocky86 firmware $ 
root@rocky86 firmware $ dmesg | grep efi:
```

## 方法三：适合虚拟机安装查看
- VMware ---> 虚拟机 ---> 设置 ---> 选项 ---> 高级
![](img/2023-09-07-17-45-33.png)

# 网卡命名规则
> [Linux Network Interface Naming](https://leo.leung.xyz/wiki/Linux_Network_Interface_Naming)
> [Consistent Network Device Naming](https://en.wikipedia.org/wiki/Consistent_Network_Device_Naming)
> [Network interface naming](https://library.netapp.com/ecmdocs/ECMP1155586/html/GUID-60DA02FA-B824-4B4E-862F-6862D1407453.html)
> [NetworkInterfaceNames](https://wiki.debian.org/NetworkInterfaceNames)


## 传统的网卡命名规则
- 传统的网卡命名统一叫 `ethX`，`X`为编号，如 `eth0`，`eth1` 等
- 编号根据启动时内核识别的顺序命名
- CentOS 6 之前版本采用

缺点：
- 如果机器上有多个网卡，一旦移除已存在的网卡或者新增网卡，
  则已存在的旧网卡名可能变化，可能造成安全隐患，如不便于防火墙制定规则管理


## 新网卡命名规则 Predictable Network Naming
- 根据硬件位置对网卡命名

命名规则：
1. 前缀
- en
ethernet
- wl
wireless LAN
- ww
wireless wide area network

2. 后缀  
- oN
onboard device, where N is the onboard index
- sN
hot plug, where N is the slot index
- xMAC
based on MAC address
- pN/sX
devices connected on a bus, where N is the bus number and X is the slot number


示例：
- `eno0` is the first onboard ethnet device
- `wlp2s1` is a wireless device located at a PCI bus 2, slot 1

# 修改新命名规则为旧命名规则
> [Linux: Disable assignment of new styled names for network interfaces](https://michlstechblog.info/blog/linux-disable-assignment-of-new-names-for-network-interfaces/)
 

- 编辑 `/etc/default/grub` 文件，在变量 `GRUB_CMDLINE_LINUX`的值中添加两个内核参数 `net.ifnames=0 biosdevname=0`

## ubuntu22.04

`ip a` 或者 `ip link` 查看初始网卡名为 ens33：
```bash
root@ubuntu22 init.d $ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:0c:29:e7:c8:8e brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    inet 10.0.0.157/24 metric 100 brd 10.0.0.255 scope global dynamic ens33
       valid_lft 921sec preferred_lft 921sec
    inet6 fe80::20c:29ff:fee7:c88e/64 scope link 
       valid_lft forever preferred_lft forever
```

1. 修改 /etc/default/grub 配置文件
```bash
root@ubuntu22 init.d $ vim /etc/default/grub

# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_TIMEOUT_STYLE=hidden
GRUB_TIMEOUT=0
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT=""
#GRUB_CMDLINE_LINUX="" #默认该变量为空

# 新增两个内核参数
GRUB_CMDLINE_LINUX="net.ifnames=0 biosdevname=0" 
```

2. 更新 /boot/grub/grub.cfg
测试系统为 BIOS 引导方式

- 方法一：执行 update-grub 命令更新 /boot/grub/grub.cfg
```bash
root@ubuntu22 init.d $ update-grub
Sourcing file `/etc/default/grub'
Sourcing file `/etc/default/grub.d/init-select.cfg'
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-5.15.0-69-generic
Found initrd image: /boot/initrd.img-5.15.0-69-generic
Found linux image: /boot/vmlinuz-5.15.0-67-generic
Found initrd image: /boot/initrd.img-5.15.0-67-generic
Warning: os-prober will not be executed to detect other bootable partitions.
Systems on them will not be added to the GRUB boot configuration.
Check GRUB_DISABLE_OS_PROBER documentation entry.
done
```

- 方法二： 执行命令 `grub-mkconfig -o /boot/grub/grub.cfg` 
结果和上面方法相同

3. 修改网卡配置文件
- 需要在 `/etc/netplan` 目录下的 `.yaml` 网卡配置文件中的网卡名改为新的网卡名
- 可以将网卡配置名字改为新网卡名，如 `eth0.yaml`
- 让网卡配置文件生效 `netplan apply`

4. reboot
此时用 `ip a` 或 `ip link` 可看到网卡名已修改，变为 `eth0`
```bash
root@ubuntu22 ~ $ ip link 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:e7:c8:8e brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    altname ens33
```


## rocky 8.6
1. 修改 /etc/default/grub 配置文件
同 ubuntu 22.04 

2. 更新 grub.cfg 配置文件
- BIOS 引导
```bash
grub2-mkconfig -o /boot/grub2/grub.cfg
```
- UEFI 引导
```bash
grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg
```
3. 重启




