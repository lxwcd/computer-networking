计算机网络学习笔记

# 学习资源

## 书籍
> 小白入门计算机网络知识：计算机网络 谢希仁 第 7 版
> 看完 计算机网络 后可以补充看：图解TCP_IP
> linux 上学习网络工具，实操：鸟哥的Linux私房菜服务器架设篇
> 对计算机基础网络知识有一定了解后看，提到很多概论，拓展知识：趣谈网络协议 刘超 



## 视频
> [PowerCertAnimatedVideos](https://www.youtube.com/@PowerCertAnimatedVideos)


## 学习过程
1. 学习计算机网络基础知识
- 看谢希仁的**计算机网络（第 7 版）** 前 7 章，了解计算机网络基础知识
- 快速看**图解TCP_IP（第 5 版）**，作为查漏补缺
- 鸟哥的Linux私房菜服务器架设篇，学习 linux 中网络工具使用


# 计算机网络基础知识
主要笔记在**计算机网络**和**图解TCP_IP**两本书的笔记中，这里做一些零碎补充

## LAN WAN SUBNET
> [LAN, WAN, SUBNET - EXPLAINED](https://www.youtube.com/watch?v=NyZWSvSj8ek&ab_channel=PowerCertAnimatedVideos)


## 计算机网络体系分层的目的
> [计算机网络为什么要分层](https://www.cnblogs.com/ricklz/p/16457713.html)
> 计算机网络 谢希仁 第7版 1.7

相互通信的计算机必须协调工作，而这种协调十分复杂，分层可以将复杂的问题转换为若干较小的局部问题

分层的好处如下：
- 各层之间独立
每一层不用关心其他层如何实现，仅需知道层间接口所提供的服务
下层对上层透明

- 灵活性好
任意一层发生发生变化，只要层间接口不变，不影响其他层

- 结构上可分割开
各层可以采用最适合自己的技术实现

- 易于实现和维护
不用调试一个十分庞大而复杂的系统，因为每层为一个相对独立的子系统

- 促进标准化工作
每层有自己明确的功能，且有精确说明


分层的缺点：
- 可能有些功能在不同层重复出现而产生额外开销


计算机网络的各层及其协议的集合就是网络的体系结构 (architecture)
计算机的体系结构就是计算机网络及其构件所应完成的功能的精确定义
体系结构是抽象的，其实现靠具体的硬件和软件

## 透明
在计算机网络中，"透明"是一个重要的概念，表示某个组件或系统对于其他组件或系统来说是不可见的，或者说对其他组件的行为没有显著的影响。

以下是几个计算机网络中"透明"概念的例子：

1. 物理层对数据链路层透明：物理层尽可能**屏蔽掉传输媒体和通信手段的差异，使物理层上层的数据链路层感觉不到这些差异**，只用考虑如何完成本层的协议和服务。

2. 传输层透明：在网络通信中，传输层的透明性是指对于应用层来说，传输层提供的传输服务是无差别的，无论底层网络使用的是哪种技术或协议。例如，TCP协议在底层可以使用以太网、Wi-Fi或者其他网络技术实现，但应用程序不需要关心底层的具体实现细节，只需使用统一的套接字接口进行数据的发送和接收。

3. 路由器透明：在计算机网络中，路由器是负责将数据包从源地址转发到目标地址的网络设备。路由器的透明性意味着它在转发数据包时不会对数据内容进行修改或解析。无论是文本、图像还是视频数据，路由器都会透明地将它们传递到下一个网络节点，而不会对数据包本身产生任何影响。

4. 隧道透明：隧道是一种将一个协议的数据封装在另一个协议的数据包中进行传输的方式。隧道协议的透明性表明，封装在隧道中的数据将在传输过程中被保持原样，不会被修改或解析。这样，隧道的两端可以是不同网络或不同协议的设备，但它们仍然可以通过隧道进行通信。

5. 加密透明：加密透明是指在网络通信中使用加密技术时，对于通信的两端来说，使用加密算法进行数据加密和解密是透明的。通信的两端可以像使用非加密通信一样发送和接收数据，中间的加密和解密过程对它们是透明的。这为安全的网络通信提供了便利，同时确保了用户数据的隐私和保密性。

这些例子展示了计算机网络中的"透明"概念，即某个组件或系统的行为对其他组件来说是不可见的。透明性帮助网络中的各个组件相互协作，并简化了网络通信和管理的复杂性。


## 五层协议
OSI 七层协议
- 物理层，数据链路层，网络层，运输层，会话层，表示层，应用层
- 理论模型

TCP/IP 四层协议
- 网络接口层，网际层，运输层，应用层
- 实际使用

五层协议划分
- 物理层，数据链路层，网络层，运输层，应用层

### 物理层
- physical layer
- 传输的数据单位为比特，考虑的是用多大电压表示 1 和 0 以及接收方如何识别发送的比特（编码方式等）
- 物理层还要考虑与传输媒介，如双绞线等接口的一些特性，但具体传输媒介的特性不属于物理层，是在物理层之下
- 物理层尽可能**屏蔽掉传输媒体和通信手段的差异，使物理层上层的数据链路层感觉不到这些差异**，只用考虑如何完成本层的协议和服务

### 数据链路层
- data link layer

数据链路层要解决的三个问题：
- 封装成帧 (framing)
帧的首部和尾部用于帧定界，且包括许多必要的控制信息，发送帧时从帧的首部开始发送。
数据链路层协议对帧首部和帧尾部的格式有明确的规定，也规定了帧的数据部分长度上限，即最大传输单元 **MTU** （Maximum Transfer Unit）。不同数据链路的 MTU 不同。

- 透明传输 
无论什么比特组合的数据，都能按照原样没有差错的通过数据链路层，即数据链路层对这些数据透明
传输的数据不会因为帧定界的方式与数据的来源不兼容而出现错误

- 差错检测
数据链路层将数据封装成帧中包含数据和控制信息，控制信息中含有差错控制，发现差错则丢弃帧
数据链路层使用 CRC 检验，能实现无比特差错的传输，但不是可靠传输，即数据链路层不会检验帧丢失，帧重复或帧失序等差错

对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不向上层提供可靠的传输服务
对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，即不向上层提供可靠的传输服务

### 网络层
- network layer

将运输层产生的报文段或用户数据报封装成分组或包传送给分组交换网上的不同主机
选择合适的路由使得源主机的数据包能到达目的主机

### 运输层
- transport layer

运输层负责向两台主机中进程之间的通信提供通用的数据传输服务，通用指多个应用能使用一个运输层服务

运输层有复用和分用的功能，复用表示多个应用层进程同时使用运输层的服务，
分用表示运输层将收到的信息分别交付给应用层中的相应进程

运输层向高层用户屏蔽下面网络核心的细节（如网络拓扑、所采用的路由协议等），使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。

### 应用层
- application layer

应用层通过应用进程间的交互来完成特定网络应用
应用层协议定义应用进程间通信和交互的规则

## 三层网络模型
> [Build Your Skills: The three-layer hierarchical model](https://www.techrepublic.com/article/build-your-skills-the-three-layer-hierarchical-model/)
> [3 Layer Cisco Hierarchical Model](https://ipwithease.com/3-layer-cisco-hierarchical-model/)
> [Three-Layer Hierarchical Model in Cisco](https://www.geeksforgeeks.org/three-layer-hierarchical-model-in-cisco/)
> [Network Topology Architectures (2-tier and 3-tier) | Cisco CCNA 200-301](https://www.youtube.com/watch?v=XHlr791Lid0&ab_channel=KeithBarker-TheOGofIT)
> [CCNA Training CBT - Cisco Three Layer Hierarchical Model](https://www.youtube.com/watch?v=vCneK-9nVyI&ab_channel=ITdvds)


- 接入层（access layer）
    - 连接终端到局域网中，如 VLAN 在接入层分开广播域，或者路由器划分的子网。
    - use switches or hubs

- 分发层（distribution layer）
    - 也叫汇聚层，如连接接入层不同的 VLAN，或者接入层不同的子网；如果接入层划分不同子网，分发层连接不同的子网，这些子网仍然属于一个局域网，分发层的路由器有一个路由表用来过滤数据包决定分发给哪个子网。
    - 例如防火墙，NAT 配置等在分发层。
    - use routers to connect multiple networks together

- 核心层（core layer）
    - 复杂高速数据转发，连接分发层的各个设备。


## 集线器 Hub
- 工作在物理层，仅简单地转发比特，半双工通信
- 不进行碰撞检测，因此有 CSMA/CD 协议，保证同一时刻只有一个站点发送数据

## 以太网交换机 switch
- 工作在数据链路层，全双工通信，能隔离冲突域
- 以太网交换机实质是多接口网桥，网桥只有两个接口，以太网交换机接口更多。
- 以太网交换机使用了专门的交换结构芯片，用硬件转发，其转发速率比普通网桥快。
- 以太网交换机有存储器，能进行帧缓存。
- 以太网交换机内有交换表，能进行自学习，交换表中每个条目是每个端口号以及对应的 MAC 地址，交换表有一定的有效时间，过期就删除。
- 以太网交换机是即插即用设备，因为其自有自学习能力，不必人工配置。
- 以太网交换机一般有多种速率接口。 
- 以太网交换机大多数对帧采用存储转发的方式，但也有些采用直通方式交换，直通交换不进行差错检测就将帧发出去。
- 以太网是全双工通信方式。


## 网络接口与网络适配器
### 网络接口（network interface）
> [Network interfaces](https://learn.microsoft.com/en-us/windows/win32/network-interfaces)

- 计算机与网络之间的连接点 
- 可以是物理的，也可以是虚拟的
- 允许计算机通过网络发送和接收数据

### 网络适配器（network adapter）
- 也叫网络接口卡（network interface card）
- 是一种硬件设备，提供计算机与网络之间的物理连接

## 广播域与冲突域
> [Broadcast Domains and Collision Domains - CompTIA Network+ N10-007 - 1.3](https://www.youtube.com/watch?v=SGbtLjIEVeo&ab_channel=ProfessorMesser)
> [CSMA/CD and CSMA/CA Explained](https://www.youtube.com/watch?v=iKn0GzF5-IU&t=103s&ab_channel=PowerCertAnimatedVideos)

- broadcast domain and collision domain

### collision domain
在以太网中，当两个设备同时将数据包发送到同一物理链路上时，这些数据包可能会在传输过程中发生碰撞，导致数据包损坏。
这是因为以太网使用的是半双工通信方式，设备不能同时发送和接收数据。
碰撞域的存在会限制网络的传输效率和可靠性。


- hub 连接的主机为一个 collision domain
- 同一时刻最多只允许一个站点发送数据
- 各主机的网络适配器执行 CSMA/CD 协议以避免冲突
- switch 能隔离冲突域，switch 是全双工通信，且有存储器能对数据进行缓存

### broadcast domain
广播域是指网络中的一组设备，当其中一个设备发送广播消息时，其他设备都能够接收到该消息
广播是一种发送到本地网络上的特殊数据包，其目标地址为广播地址，例如IPv4中的255.255.255.255

- 第二层以太网交换机所连接的设备属于一个广播域
- ARP 广播会在一个广播域中传输
- VLAN 可以隔离广播域
- 路由器可以隔离广播域

## 网络环路和生成树协议 STP
查看 **趣谈网络协议 2.2 节**的讲解


## VLAN 
> [VLAN Explained](https://www.youtube.com/watch?v=jC6MJTh9fRE&ab_channel=PowerCertAnimatedVideos)

- 从逻辑上划分广播域，限制接收广播风暴的计算机数量
- 工作在数据链路层
- 在以太网帧中加入一个 VLAN 标志，占 4 字节，但实际可分配的主机数只有 12 位，即 4096 个主机
- 对交换机有要求
- 二层的交换机只能在一个局域网中划分广播域

## IP 地址和 MAC 地址的区别
> [MAC Address Explained](https://www.youtube.com/watch?v=TIiQiw7fpsU&ab_channel=PowerCertAnimatedVideos)


![](https://img-blog.csdnimg.cn/23b18ee986bb4b04a797e4740fac3195.png)
![](https://img-blog.csdnimg.cn/cb17f7e950c64d7ca660ecb403d4c264.png)


- 在 IP 层抽象的互联网上只能看到 IP 数据报，屏蔽了下层网络硬件地址体系的不同等复杂细节。
- 互联网可以由很多[异构网](https://en.wikipedia.org/wiki/Heterogeneous_network)组成，使用 IP 协议让互联网上的主机好像在一个单个网络上通信，而不用管各网络的具体异构细节。
- IP 数据报首部的源地址和目的地址始终不变，是最终的源和目的地址
- 路由器进行路由是依据 IP 地址，IP 地址更有规律，适合路由器进行路由管理
- IP 地址是软件实现的逻辑地址，很容易变化；物理地址是硬件地址，在网络适配器的 ROM 中，一般不会变化
- 局域网的数据链路层只能看见 MAC 帧，以太网交换机的交换表是根据 MAC 地址进行转发
- MAC 帧经过不同的网络时，其帧首部的源地址和目的地址都要变化，源地址变为当前发送的地址，目的地址下一跳的地址


## 子网（subnet）和 虚拟局域网 VLAN 区别
> [LAN, WAN, SUBNET - EXPLAINED](https://www.youtube.com/watch?v=NyZWSvSj8ek&list=LL&index=5&ab_channel=PowerCertAnimatedVideos)
> [VLAN Explained](https://www.youtube.com/watch?v=jC6MJTh9fRE&t=1s&ab_channel=PowerCertAnimatedVideos)
> [Subnets vs VLANs](https://www.youtube.com/watch?v=6_giEv20En0&list=LL&index=6&ab_channel=PowerCertAnimatedVideos)


- 划分子网是在网络层，通过路由器划分，不同的子网仍属于一个局域网（LAN）。
- 子网是对 IP 地址的主机号分出一些位数作为子网号
- VLAN 是在数据链路层划分，通过以太网交换机，在 MAC 地址中增加一个标志位来区分，逻辑上划分为多个广播域，但多个广播域仍然在一个局域网中。
- 子网是在物理上划分，VLAN 是在逻辑上划分，都是分割不同的广播域。
- 子网和 VLAN 划分均在访问层（access layer），但连接不同的 VALN 和子网则是在 distribution layer。
- 可能有些场景不能使用 VLAN，只能在网络层划分子网。

## TCP 和 UDP 的区别
1. TCP 是面向连接的，UDP 面向无连接
- 面向连接指互相通信前先建立连接
- TCP 进行三次握手来建立连接，而 UDP 不建立连接
TCP 建立连接的原因：
1) 确保双方都准备好进行通信：在建立TCP连接之前，客户端和服务器需要确保双方都已经准备好进行通信。通过三次握手，客户端和服务器可以确保彼此都处于可达状态，并且可以正常地发送和接收数据。

2) 同步序列号 (Synchronize Sequence Numbers)：在三次握手过程中，服务端和客户端将交换彼此的初始序列号（ISN），以确保双方建立起相同的初始序列号。

序列号用于对TCP数据包进行排序和重组。在建立连接时同步序列号非常重要，因为它们用于标识每个TCP连接中的数据包顺序，并帮助检测和处理重复或丢失的数据包。

3) 确认连接请求和响应：通过三次握手，客户端向服务器发送一个连接请求报文段（SYN），表示客户端希望建立连接。 服务器收到请求后，会回复一个确认报文段（SYN-ACK），以确认收到连接请求，并表示服务器也准备好建立连接。最后，客户端再次回复一个确认报文段（ACK），表示已经接收到服务器的确认，并且连接已经建立。

这样来回的确认过程可以防止服务器收到多个重复的连接请求，以及客户端在发送请求后一段时间后便关闭的情况。通过三次握手，确保连接的可靠性和可用性。

2. TCP 不支持广播或多播通信，UDP 可以一对多或多对多等通信
TCP 需要建立连接，数据传送结束要释放连接，因此不支持一对多
UDP 是无连接的，因此可以进行一对多通信

3. TCP 是面向字节流的，UDP 是面向报文的
应用程序交付给 TCP 的是数据块，但 TCP 将其仅看成一连串无结构的字节流，字节流中的每个字节都被按序编号
TCP 连接的连接的两端有发送缓存和接收缓存，提供全双工通信，不关心应用程序一次将多长的报文发送到 TCP 缓存中，
TCP 是根据对方给出的窗口值和当前网络的拥塞程度决定发送多少字节

UDP 对应用层交付的报文不合并也不拆分，添加首部数据后就交给 IP 层，因此应用层最好选择合适大小的报文，
如果报文太长，到 IP 层后需要分片，会降低 IP 层的效率
报文太短也会降低 IP 层的效率

4. TCP 提供可靠交付，UDP 不保证可靠交付
TCP 是有状态的服务，会跟踪数据包发送状态，而 UDP 是无状态的，不管数据是否发送成功或者有无差错等

TCP 能提供可靠传输的原因：
- 面向连接 Connection-oriented
TCP 在通信前进行三次握手和通信结束后四次挥手保证数据的完整交换

- 确认和重传机制
接收方收到数据后会发送 acknowledgments (ACK) 给发送方以告知对方自己收到数据
如果发送方在一定时间内没有收到 ACK 确认消息，则重传数据包
该机制确保数据不丢失

- 为每个字节分配序号
TCP 在建立连接时会发送初始序号 (sequence number)，此后传输数据的包会依序编号，接收方在发送确认消息时也会指明下次发送的序号
接收方根据序号重组数据，保证数据无差错，按序到达

- 流量控制（flow control）
TCP 利用滑动窗口机制让发送方的发送速率不要太快，以便接收方来得及接收

- 拥塞控制（Congestion control）
TCP 通过监控网络拥塞程度来避免过多的数据注入到网络中，使网络中的路由器或链路不至于过载而影响通信


## TCP 流量控制和拥塞控制的区别

## **流量控制**
![](https://img-blog.csdnimg.cn/8c82283d045f4a3292add077cbbb7f0d.png)
![](https://img-blog.csdnimg.cn/9e02ada12cd04c63b0071a76ccd27f46.png)

流量控制是TCP中的一种机制，用于控制发送方向接收方发送数据的速率，以确保接收方能够及时处理接收到的数据，并防止发送方发送速度过快而导致数据丢失或溢出。
TCP使用滑动窗口机制来进行流量控制。

滑动窗口机制由发送窗口和接收窗口组成。发送窗口是发送方允许发送的字节数量的上限，而接收窗口是接收方能够接收的字节数量的上限。
接收方通过在TCP报文段中的确认号来通知发送方自己的接收窗口大小。
发送方根据接收窗口的大小调整自己发送数据的速率，确保不超过接收方的处理能力。

## **拥塞控制**
![](https://img-blog.csdnimg.cn/57abfeb6440e4ddebb4adab851a0ffc4.png)

拥塞控制是TCP中的另一种机制，用于控制数据在网络中的传输速率，以避免网络拥塞并保持网络的稳定性。
拥塞控制通过监视网络的负载情况和网络的拥塞程度来调整数据的发送速率。

TCP使用一种称为拥塞窗口的方法来实现拥塞控制。拥塞窗口是发送方发送数据的速率与网络负载情况的折中值。
发送方根据网络的拥塞情况动态调整拥塞窗口的大小，以控制数据的发送速率。
拥塞控制算法通常包括慢启动、拥塞避免和快速恢复等阶段，以逐步增加发送速率并对网络拥塞做出响应。

## **拥塞控制与流量控制区别**
![](https://img-blog.csdnimg.cn/05ab7a696a424376a3c7e55c32462712.png)

1. 流量控制是为了确保接收方能够有效地接收数据并避免数据丢失或溢出，而拥塞控制是为了保持网络的稳定性和避免拥塞发生。
2. 流量控制是在发送方和接收方之间进行的，而拥塞控制是在整个网络中进行的。
3. 流量控制是根据接收方的处理能力来控制发送速率，而拥塞控制是根据网络的负载情况和拥塞程度来调整发送速率。
4. 流量控制使用滑动窗口机制来控制发送速率，而拥塞控制使用拥塞窗口算法来调整发送速率。

总的来说，流量控制是为了适应接收方的处理能力调整数据发送速率，而拥塞控制是为了避免网络拥塞并保持网络稳定性调整数据发送速率。它们是TCP协议中的两种重要机制，同时工作来确保传输的可靠性和效率。

## TCP 三报文握手
> [What is a Three-way handshake in TCP?](https://www.youtube.com/watch?v=LyDqA-dAPW4&ab_channel=Cisco)

A 客户端向 B 服务器建立连接：
1. B 服务器需要创建传输控制模块 TCB，开启端口，准备接收客户端进程的连接请求，此时服务器进程处于 LISTEN 状态

2. A 客户端进程也创建传输控制模块 TCB

3. A 向 B 发出连接请求报文，此时首部 SYN 为 1，不能携带数据，但需要消耗一个序号，此时客户进程进入 SYN-SENT 状态

4. B 收到请求报文段后，如同意建立连接，则向 A 发送确认，SYN = 1，ACK =1，返回一个确认号，选择一个初始序号，
   该报文也不能携带数据，但需要消耗一个序号，此时 B 进程进入 SYN-RECD 状态
   
5. A 进程收到 B 确认后，还需向 B 发送确认，确认报文段的 ACK=1，可以携带数据，如果不携带数据，则不消耗序号，
   此时 A 进入 ESTABLISHED 状态

6. B 收到 A 的确认后即进入 ESTABLISHED 状态

## 四报文握手
- 如果 B 发送给 A 确认时分开为两个报文段，即先发一个 ACK = 1 的确认报文段，再发一个 SYN = 1 的同步报文段，
  则变成**四报文握手**

## 建立连接需要三报文的原因

1. A 收到 B 的确认报文后还需要向 B 发送确认
- 防止已失效的连接请求又传到 B，从而产生错误 
如 A 发送连接请求的报文在网络中长时间滞留，因此 A 重新发送连接请求并与 B 建立连接，最后完成释放连接，
B 在与 A 释放连接后，又收到之前 A 发送的连接请求，以为是一次新的连接而向 A 发送确认报文段，
如果没有第三次 A 的确认报文，则连接已建立成功，而 B 会一直等待 A 发送数据，从而造成资源浪费。


*********************

> [2.4.2 TCP 的三向交握](http://cn.linux.vbird.org/linux_server/0110network_basic_4.php#tcpip_transfer_tcphand)


## TCP 四报文挥手
> [TCP-4-times-close](https://wiki.wireshark.org/TCP-4-times-close.md)

- 通信双方都可以释放连接

假设 A 进程向 B 发送连接释放报文段：
1. A 发送连接释放报文段，FIN=1，序号 seq = u (前一次发送数据的最后一个字节序号+1)，
   此后 A 停止发送数据，主动关闭 TCP 连接，A 进入 FIN-WAIT-1 状态;
   A 发送的报文段可以不携带数据，但必须消耗一个序号

2. B 发送确认，ACK=1，B 进入 CLOSE-WAIT 状态

3. 此时 TCP 连接处于**半关闭**状态，即 A 以及完成数据传输，B 仍可以发送数据，A 仍要接收

4. A 收到 B 的确认报文段后进入 FIN-WAIT-2 状态，等待 B 发送连接释放报文段

5. B 可以向 A 继续发送数据，直到没有数据传输，则发出连接释放报文段，FIN=1，ACK=1，
   以及确认号和序号，B 进入 LAST-CHECK 状态，等待 A 的确认

6. A 收到连接释放报文段后，对 B 发出确认，ACK=1，附带确认号和序号，进入 TIME-WAIT 状态，

7. 此时 TCP 连接并未释放，需要**时间等待计时器（TIME-WAIT timer）**设置的时间 2MSL 后，A 才进入 CLOSED 状态。


## TIME-WAIT 阶段的作用
> [Why does TIME_WAIT exist?](https://serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html#why-does-time_wait-exist)


> The MSL is the maximum amount of time that any segment, 
> for all intents and purposes a datagram that forms part of the TCP protocol, 
> can remain valid on the network before being discarded.


TIME-WAIT 阶段，A 等待 2MSL（最长报文段寿命，Maximum Segment Lifetime）的时间

MSL 和 IP 数据报首部的 TTL 字段有关，TTL 限制了该数据报在网络中的存活时间，超过时间即被丢弃

1. The first is to prevent delayed segments from one connection being misinterpreted as being part of a subsequent connection. 
Any segments that arrive whilst a connection is in the 2MSL wait state are discarded.

设置 2MSL 可以保证本连接中之前的已失效的报文段从网络中消失，以防止干扰下次新的连接

2. 确保 A 发送的最后一个 ACK 确认报文段能到达 B，如果该报文丢失，B 会超时重传报文，
A 就能在 2MSL 时间内重新发送最后的确认报文；A 重新发送确认报文后，重新开启了2MSL 计时器。


查看 TIME-WAIT 的时间
```bash
[20:09:49 root@ubuntu2004 ~]# sysctl net.ipv4.tcp_fin_timeout
net.ipv4.tcp_fin_timeout = 60
```

## TCP 保活计时器（Keepalive timer）
- 防止已建立连接后，客户端出现故障，服务端不用一直等待。
- 服务端收到一次客户端的数据，就重置保活计时器，时间通常 2 小时。
- 如果服务端在两小时内没有收到客户端数据，则发送一个探测报文段，
  以后每 75 秒发送一次，若连接发送 10 个探测报文段后无响应，
  则服务端认为客户端出现故障，关闭此连接。


## TCP 的 11 种有限状态机
> [TCP State Transition Diagram](https://flylib.com/books/en/3.223.1.188/1/)

- 为了更清楚看出 TCP 连接的各种状态之间的关系
- ubuntu22.04 中 `man netstat` 可以查看 `state` 状态

## 端口号
> [Port (computer networking)](https://en.wikipedia.org/wiki/Port_(computer_networking))
> [TCP port 0 reserved for what purpose?](https://networkengineering.stackexchange.com/questions/11234/tcp-port-0-reserved-for-what-purpose)


- 不是所有的应用程序都有端口，如不需要网络的应用程序，不需要端口号
- 应用程序进行网络连接时才分配端口号
- 端口号 0 是保留端口号，不能使用


**************
> [2.4.1 可靠联机的 TCP 协议](http://cn.linux.vbird.org/linux_server/0110network_basic_4.php#tcpip_transfer_tcp)

- 如果客户端想要访问一个服务器的 www 服务，则服务器会开启 80 端口等待客户端的连接
- 客户端通过浏览器访问服务器的 wwww 服务，客户端浏览器的端口则是客户端主机随机分配的

### 熟知端口号
- 0 ~ 1023
- 熟知端口号为服务器的端口号，非客户端的端口号，客户端的端口号是随机动态分配
- 熟知端口号是服务器默认端口号，不指定时默认使用的端口号，但也可以修改，修改后访问服务器时需要指定新端口号
- 只有 root 才能开启熟知端口号，因此也叫特权端口号
- `cat /etc/services | less` 查看熟知端口号，部分内容如下：
```bash
# /etc/services:
# $Id: services,v 1.49 2017/08/18 12:43:23 ovasik Exp $
#
# Network services, Internet style
# IANA services version: last updated 2016-07-08
#
# Note that it is presently the policy of IANA to assign a single well-known
# port number for both TCP and UDP; hence, most entries here have two entries
# even if the protocol doesn't support UDP operations.
# Updated from RFC 1700, ``Assigned Numbers'' (October 1994).  Not all ports
# are included, only the more common ones.
#
# The latest IANA port assignments can be gotten from
#       http://www.iana.org/assignments/port-numbers
# The Well Known Ports are those from 0 through 1023.
# The Registered Ports are those from 1024 through 49151
# The Dynamic and/or Private Ports are those from 49152 through 65535
#
# Each line describes one service, and is of the form:
#
# service-name  port/protocol  [aliases ...]   [# comment]

tcpmux          1/tcp                           # TCP port service multiplexer
tcpmux          1/udp                           # TCP port service multiplexer
rje             5/tcp                           # Remote Job Entry
rje             5/udp                           # Remote Job Entry
echo            7/tcp
echo            7/udp
discard         9/tcp           sink null
discard         9/udp           sink null
systat          11/tcp          users
systat          11/udp          users
daytime         13/tcp
daytime         13/udp
qotd            17/tcp          quote
qotd            17/udp          quote
chargen         19/tcp          ttytst source
chargen         19/udp          ttytst source
ftp-data        20/tcp
ftp-data        20/udp
# 21 is registered to ftp, but also used by fsp
ftp             21/tcp
ftp             21/udp          fsp fspd
ssh             22/tcp                          # The Secure Shell (SSH) Protocol
ssh             22/udp                          # The Secure Shell (SSH) Protocol
telnet          23/tcp
telnet          23/udp
# 24 - private mail system
lmtp            24/tcp                          # LMTP Mail Delivery
lmtp            24/udp                          # LMTP Mail Delivery
smtp            25/tcp          mail
smtp            25/udp          mail
time            37/tcp          timserver
time            37/udp          timserver
rlp             39/tcp          resource        # resource location
rlp             39/udp          resource        # resource location
nameserver      42/tcp          name            # IEN 116
nameserver      42/udp          name            # IEN 116
nicname         43/tcp          whois
nicname         43/udp          whois
tacacs          49/tcp                          # Login Host Protocol (TACACS)
tacacs          49/udp                          # Login Host Protocol (TACACS)
re-mail-ck      50/tcp                          # Remote Mail Checking Protocol
re-mail-ck      50/udp                          # Remote Mail Checking Protocol
domain          53/tcp                          # name-domain server
domain          53/udp
whois++         63/tcp          whoispp
whois++         63/udp          whoispp
```

## 监听（listening）
> [7.3.1 什么是 port](http://cn.linux.vbird.org/linux_server/0210network-secure_3.php#portlimit_what)

- 监听（listening）是某个服务程序会一直常驻内存，因此该服务程序启动的 port 会一直存在

## 解耦（decoupling）
> [Coupling](https://en.wikipedia.org/wiki/Coupling_(computer_programming))
> [The Importance Of Decoupling In Software Development](https://cloudcomputingtechnologies.com/the-importance-of-decoupling-in-software-development/)


> [Decoupled](https://www.techopedia.com/definition/598/decoupled)
> &nbsp;
> In theory, this means that a change can be made to one service without the developer having to worry about how the change will impact other services — as long as the service's application programming interface (API) remains the same.

## 域名作用
- IP 转换为域名方便记忆
- 解耦，业务不用依赖具体 IP，即使 IP 地址变化，也不受影响

## **域名解析顺序**
> [What is DNS? How it works?](https://medium.com/@Betulince/what-is-dns-how-it-works-12ea45b27e75)

ubuntu22.04 测试

- 先查 /etc/hosts 文件
有些域名解析工具会忽略 `/etc/hosts`

- 再查本机缓存
ubuntu22.04 用 `resolvectl` 命令查看 DNS 缓存
ubuntu20.04 用 `systemd-resolve` 命令查看 DNS 缓存

- 本地无记录，找配置的 DNS 域名服务器查询

### 测试
- ubuntu22.04
1. ping www.baidu.com 正常通信
2. 查看 dns 缓存中的记录
```bash
[root@es ~]$ killall -USR1 systemd-resolved && journalctl -u systemd-resolved | grep -A 100 "CACHE:"
Sep 08 09:42:40 es systemd-resolved[799]: CACHE:
Sep 08 09:42:40 es systemd-resolved[799]:         www.baidu.com IN CNAME www.a.shifen.com
Sep 08 09:42:40 es systemd-resolved[799]:         www.a.shifen.com IN A 180.101.50.242
Sep 08 09:42:40 es systemd-resolved[799]:         www.a.shifen.com IN A 180.101.50.188
```
3. 修改 /etc/hosts 文件
添加记录
```bash
1.2.3.4 www.baidu.com
```
4. ping www.baidu.com
```bash
[root@es ~]$ ping www.baidu.com
PING www.baidu.com (1.2.3.4) 56(84) bytes of data.
```
无法 ping 通 www.baidu.com，ip 地址不对
5. host www.baidu.com 查看 ip
```bash
[root@es ~]$ host www.baidu.com
www.baidu.com has address 1.2.3.4
www.baidu.com is an alias for www.a.shifen.com.
```
第一条记录是  /etc/hosts 文件解析


## 静态文件解析 `/etc/hosts` 
> [hosts(file)](https://en.wikipedia.org/wiki/Hosts_(file))
> [How to reload /etc/hosts after editing in Linux?](https://linuxhint.com/reload-edited-etchosts-linux/)

- linux: /etc/hosts
- windows11: %windir%/system32/drivers/etc/hosts
- host 文件中列出域名与 IP 对应的关系

- hosts 文件解析域名是早期网络规模较小时使用的方案
- 管理机构提供该文件的下载地址并定期更新
- 早期使用方案，但网络规模太大后不适用，因此之后引入 DNS 服务器提供域名解析服务

- 主机中的文本文件，定义域名和 IP 地址的对应关系
- DNS 解析时最先查看的文件，找到对应 IP 则直接请求 IP 地址，如 ping 命令会找该文件，但有些域名解析工具会忽略该文件
- hosts 文件中找不到，则会向本机配置的 DNS 服务器提出域名解析请求
- 修改该文件后会立即生效，除非某些情况该文件被应用程序缓存了

## 本地 DNS 缓存
> [DNS Caching in Linux](https://www.baeldung.com/linux/configure-dns-caching)

- DNS 缓存是临时的，开机时没有缓存，如果用 `ping` 后将该记录缓存
- 解析 DNS 时先查本机缓存

- ubuntu22.04 用 `resolvectl` 命令查看 DNS 缓存
```bash
root@router ~ $ resolvectl statistics
DNSSEC supported by current servers: no

Transactions
Current Transactions: 0
  Total Transactions: 16

Cache
  Current Cache Size: 3
          Cache Hits: 1
        Cache Misses: 21

DNSSEC Verdicts
              Secure: 0
            Insecure: 0
               Bogus: 0
       Indeterminate: 0
root@router ~ $ resolvectl query www.baidu.com
www.baidu.com: 124.237.176.3                   -- link: eth2
               124.237.176.4                   -- link: eth2
               (www.a.shifen.com)

-- Information acquired via protocol DNS in 32.1ms.
-- Data is authenticated: no; Data was acquired via local or encrypted transport: no
-- Data from: network
```

- ubuntu20.04 用 `systemd-resolve` 命令查看 DNS 缓存
```bash
[11:12:33 root@ubuntu2004 ~]#systemd-resolve --statistics
DNSSEC supported by current servers: no

Transactions
Current Transactions: 0
  Total Transactions: 275

Cache
  Current Cache Size: 0
          Cache Hits: 0
        Cache Misses: 24

DNSSEC Verdicts
              Secure: 0
            Insecure: 0
               Bogus: 0
       Indeterminate: 0
```

- rocky8 用 systemd-resolve 查看
```bash
[root@nfs ~]$ systemd-resolve --statistics
DNSSEC supported by current servers: yes

Transactions
Current Transactions: 0
  Total Transactions: 2

Cache
  Current Cache Size: 0
          Cache Hits: 0
        Cache Misses: 0

DNSSEC Verdicts
              Secure: 0
            Insecure: 0
               Bogus: 0
       Indeterminate: 0
```
也可以用 `nscd`，但默认未安装
```bash
[root@nfs ~]$ whatis nscd
nscd (8)             - name service cache daemon
```

### 查看 dns 缓存内容
- ubuntu22.04
```bash
[root@es ~]$ killall -USR1 systemd-resolved && journalctl -u systemd-resolved | grep -A 100 "CACHE:"
Sep 08 09:42:40 es systemd-resolved[799]: CACHE:
Sep 08 09:42:40 es systemd-resolved[799]:         www.baidu.com IN CNAME www.a.shifen.com
Sep 08 09:42:40 es systemd-resolved[799]:         www.a.shifen.com IN A 180.101.50.242
Sep 08 09:42:40 es systemd-resolved[799]:         www.a.shifen.com IN A 180.101.50.188
Sep 08 09:42:40 es systemd-resolved[799]: [Scope protocol=dns]
Sep 08 09:42:40 es systemd-resolved[799]: [Server 10.0.0.2 type=link interface=eth0]
--
Sep 08 09:43:12 es systemd-resolved[799]: CACHE:
Sep 08 09:43:12 es systemd-resolved[799]:         www.baidu.com IN CNAME www.a.shifen.com
Sep 08 09:43:12 es systemd-resolved[799]:         www.a.shifen.com IN A 180.101.50.242
Sep 08 09:43:12 es systemd-resolved[799]:         www.a.shifen.com IN A 180.101.50.188
Sep 08 09:43:12 es systemd-resolved[799]: [Scope protocol=dns]
Sep 08 09:43:12 es systemd-resolved[799]: [Server 10.0.0.2 type=link interface=eth0]
```


## 127.0.0.53
- man systemd-resolved.service

ubuntu22.04 中查看 `/etc/resolv.conf` 时其域名服务器为 127.0.0.53

通过 `ss -ntl` 可以看到本地换回网卡（lo）监听一个 `53` 端口，用来处理本地的 dns 解析

当需要解析域名时，先在本地解析，查看 `/etc/hosts` 和本机 dns 缓存，ubuntu22.04 测试 `/etc/hosts` 文件的优先级高
如果本地无法解析，则用配置的外部 dns server 解析 
(If the record is not found in the cache, the local DNS resolver acts as a client and sends the DNS query to the configured upstream DNS server)

如本地缓存有 www.baidu.com 的解析，然后在 `/etc/hosts` 文件中将该域名解析到另一个 IP，则用 ping 命令时使用的 ip 
为 /etc/hosts 文件中的 ip
用 host 命令查看：
```bash
[root@es ~]$ host www.baidu.com
www.baidu.com has address 1.2.3.4
www.baidu.com is an alias for www.a.shifen.com.
```
第一条记录为 `/etc/hosts` 文件的解析，第二条为 dns 缓存的信息

用 nslookup 看：
```bash
[root@es ~]$ nslookup www.baidu.com
Server:         127.0.0.53
Address:        127.0.0.53#53

Name:   www.baidu.com
Address: 1.2.3.4
```

如果手动修改 `/etc/resolv.conf` 文件，将 nameserver 改为 `10.0.0.2`，不用 `10.0.0.53`，
ping www.baidu.com 仍然得不到正确的地址，因为会先找 `/etc/hosts` 文件，
再用 `host` 和 `nslookup` 命令查看
```bash
[root@es ~]$ host www.baidu.com
www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 180.101.50.188
www.a.shifen.com has address 180.101.50.242
[root@es ~]$ nslookup www.baidu.com
Server:         10.0.0.2
Address:        10.0.0.2#53

Non-authoritative answer:
www.baidu.com   canonical name = www.a.shifen.com.
Name:   www.a.shifen.com
Address: 180.101.50.242
Name:   www.a.shifen.com
Address: 180.101.50.188
```

## DNS 域名系统
> [DNS Records Explained](https://www.youtube.com/watch?v=HnUDtycXSNE&list=LL&index=1&t=625s&ab_channel=PowerCertAnimatedVideos)

- DNS 只解析域名，不负责 IP 是否可达


# 查看启动方式是 BIOS 还是 UEFI
> [Guide To Check UEFI or BIOS In Windows/Linux System](https://servonode.com/check-uefi-or-bios-in-widows-or-linux)

## 方法一：查看 /sys/firmware/efi 目录

`/sys/firmware/efi` 目录存在则为 UEFI 启动

- ubuntu20.04 UEFI 启动
```bash
[10:17:49 root@ubuntu2004 /sys/firmware]#ls
acpi  dmi  efi  memmap
[10:17:50 root@ubuntu2004 /sys/firmware]#
```

- rocky8.6 BIOS 启动
```bash
root@rocky86 ~ $ cd /sys/firmware/
root@rocky86 firmware $ ls
acpi  dmi  memmap  qemu_fw_cfg
```

## 方法二：dmesg

- ubuntu20.04 UEFI 启动
```bash
root@ubuntu2004 ~# dmesg | grep efi:
[    0.000000] efi: EFI v2.60 by HUAWEI
[    0.000000] efi:  ACPI 2.0=0x8f7fe014  SMBIOS=0x8c4ed000  SMBIOS 3.0=0x8c4eb000  ESRT=0x8c4e9c18  MEMATTR=0x88fd9018  MOKvar=0x88fd7000 
```

- rocky8.6 BIOS 启动
```bash
root@rocky86 firmware $ dmesg | grep efi
[    0.000000] clocksource: refined-jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1910969940391419 ns
[    5.408252] tsc: Refined TSC clocksource calibration: 2918.420 MHz
root@rocky86 firmware $ 
root@rocky86 firmware $ dmesg | grep efi:
```

## 方法三：适合虚拟机安装查看
- VMware ---> 虚拟机 ---> 设置 ---> 选项 ---> 高级
![](img/2023-09-07-17-45-33.png)


# 查看主机 IP 地址
- ip a
- hostname -I

# 查看本机访问公网使使用的 IP 
## 网站查询
> [Determine Your Private and Public IP Addresses from the Command Line](https://www.linuxtrainingacademy.com/determine-public-ip-address-command-line-curl/)

```bash
[root@rocky8-3 ~]$ curl http://ip.sb
122.110.90.1
```
```bash
[root@rocky8-3 ~]$ curl cip.cc
IP      : 122.110.90.1
地址    : 中国  北京
运营商  : 电信

数据二  : 北京市 | 电信

数据三  : 中国北京北京市 | 电信

URL     : http://www.cip.cc/122.110.90.1
```

## dig 命令
> [How To Find My Public IP Address From Linux CLI](https://www.cyberciti.biz/faq/how-to-find-my-public-ip-address-from-command-line-on-a-linux/)


```bash
[root@rocky8-3 ~]$ dig +short myip.opendns.com @resolver1.opendns.com
115.171.61.7
```

# 查看当前网络接口
> [What is the virbr0 interface used for](https://askubuntu.com/questions/246343/what-is-the-virbr0-interface-used-for)
> [abelardojarab/virbr0_ifconfig_explanation.md](https://gist.github.com/abelardojarab/e10ed30ab69bf9636929e17e3446bc2a)
> [libvirt](https://wiki.libvirt.org/Networking.html)

## ip a 
- `ip a` 或 `ip addr` 或 `ip addr show`
### rocky8.6
- vmware 安装 rocky8.6 虚拟机查看，配置网卡为 NAT 模式
- `ip a` 命令查看
- 可看到三个网络接口
- `lo` 为本地环回测试接口，ip 为 `127.0.0.1`
- 一块网卡 `eth0`（名字被修改过），该网卡是创建虚拟机时添加的网卡，选择的模式为 NAT 模式
- `eht0` 的 ip 为 10.0.0.158，是虚拟网络中使用的 ip，和外部通信时会被 NAT 设备转换为物理主机的 ip 
- `virbr0` 是虚拟网络接口，即 virtual bridge 0，用于 NAT
- `virbr0` 由 [libvirt](https://wiki.libvirt.org/Networking.html)库提供

```bash
root@Rocky8 ~ $ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:88:25:14 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.158/24 brd 10.0.0.255 scope global dynamic noprefixroute eth0
       valid_lft 1729sec preferred_lft 1729sec
    inet6 fe80::20c:29ff:fe88:2514/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default qlen 1000
    link/ether 52:54:00:69:47:f2 brd ff:ff:ff:ff:ff:ff
    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever
root@Rocky8 ~ $ 
root@Rocky8 ~ $ cd /etc/sysconfig/network-scripts/
root@Rocky8 network-scripts $ ls
ifcfg-eth0
```


## ip link 
- `ip link` 或 `ip link show`
```bash
root@Rocky8 network-scripts $ ip link 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:88:25:14 brd ff:ff:ff:ff:ff:ff
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1000
    link/ether 52:54:00:69:47:f2 brd ff:ff:ff:ff:ff:ff
```

## 查看网络接口配置文件
- 一个网络接口对应一个配置文件，在该配置文件中设置 ip，netmask 等

# 网络相关配置文件 
> [4.1.3 Linux 网络相关配置文件](http://cn.linux.vbird.org/linux_server/0130internet_connect_1.php#note_files)

# 查看网卡配置文件
> 网卡配置文件参数介绍：[nm-settings-ifcfg-rh](https://developer-old.gnome.org/NetworkManager/stable/nm-settings-ifcfg-rh.html)

## rocky8.6
> [11.2.4 About the /etc/sysconfig/network File](https://docs.oracle.com/en/operating-systems/oracle-linux/6/admin/about-etc-sysconfig.html)


- `/etc/sysconfig/network-scripts/` 目录

如用 `ip a` 查看有网卡的名为 `eth0`
```bash
[lx@Rocky8 ~]$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:88:25:14 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.158/24 brd 10.0.0.255 scope global dynamic noprefixroute eth0
       valid_lft 1775sec preferred_lft 1775sec
    inet6 fe80::20c:29ff:fe88:2514/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

则 `/etc/sysconfig/network-scripts/` 目录内有一个名为 `ifcfg-eth0` 的文件，设置网卡的信息：
```bash
[root@Rocky8 lx]# cd /etc/sysconfig/network-scripts/
[root@Rocky8 network-scripts]# ls
ifcfg-eth0-eth2

[root@Rocky8 network-scripts]# cat ifcfg-eth0
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
NAME=eth0
UUID=7fb201c8-1ad7-4ad5-9e94-44ac4fa4faa8
DEVICE=eth0
ONBOOT=yes
```
1. TYPE 局域网类型
- 第一行表名局域网类型为以太网
2. PROXY_METHOD
3. BROWSER_ONLY
4. BOOTPROTO 获取 ip 的方式
- dhcp 表示通过 DHCP 服务自动获取
- none 表示手动设置
5. DEFROUTE 默认路由
6. IPV4_FAILURE_FATAL
7. IPV6INIT
8. NAME 该配置的名字
- 只该网络接口配置的名字，用 `nmcli` 工具时使用的名字
- 可以和设备名相同，也可以不同
```bash
root@Rocky8 network-scripts $ nmcli connection 
NAME    UUID                                  TYPE      DEVICE 
eth0    7fb201c8-1ad7-4ad5-9e94-44ac4fa4faa8  ethernet  eth0   
virbr0  25fcd9c2-6677-453b-a64d-366e2622174e  bridge    virbr0
```
9. UUID 网络接口的 UUID
10. DEVICE 网络接口的设备名
必须和该文件名的第二部分一致，也和 `ip a` 看到的设备名一致
11.  ONBOOT 开机启动
- `yes` 表示开机启动该网络接口

************
其他未列出来的设置
1. IPADDR 手动指定 ip 地址
- 不用 DHCP 自动分配 ip 时指定
2. NETMASK 子网掩码
- 如 `255.255.255.0`
3. PREFIX 子网掩码位数
- 如 `255.255.255.0` 子网掩码可以直接写 `PREFIX=24`
4. GATEWAY 网关
- 整个主机的 default gateway
- 不能重复设置，如配置几个网络接口，但每个配置文件设置不同的默认网关
5. MTU
- 以太网默认 1500，也可自己设置
6. HARDADDR 网络接口的地址，MAC 地址
7. DOMAIN 域后缀
8. DNS1 主 DNS
9. DNS2 次 DNS
10. DNS3 第三 DNS

## ubuntu22.04
> [How to Configure Networking in Ubuntu 20.04 with NetPlan](https://www.serverlab.ca/tutorials/linux/administration-linux/how-to-configure-networking-in-ubuntu-20-04-with-netplan/)

- `/etc/netplan` 目录中以 `.yaml` 结尾的文件

```bash
root@ubuntu22 ~ $ ip link 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:12:a4:95 brd ff:ff:ff:ff:ff:ff
    altname enp2s1

root@ubuntu22 ~ $ cd /etc/netplan/
root@ubuntu22 netplan $ ls
00-installer-config.yaml

root@ubuntu22 netplan $ cat 00-installer-config.yaml 
# This is the network config written by 'subiquity'
network:
  ethernets:
    ens33:
      dhcp4: true
  version: 2
```

# 查看网卡的硬件信息
## lshw -class network

```bash
root@ubuntu22 ~ $ lshw -class network
  *-network                 
       description: Ethernet interface
       product: 82545EM Gigabit Ethernet Controller (Copper)
       vendor: Intel Corporation
       physical id: 1
       bus info: pci@0000:02:01.0
       logical name: eth0
       version: 01
       serial: 00:0c:29:e7:c8:8e
       size: 1Gbit/s
       capacity: 1Gbit/s
       width: 64 bits
       clock: 66MHz
       capabilities: pm pcix bus_master cap_list rom ethernet pgotiation
       configuration: autonegotiation=on broadcast=yes driver=elatency=0 link=yes mingnt=255 multicast=yes port=twisted pair s
       resources: irq:19 memory:fd5c0000-fd5dffff memory:fdff00
```

# 检查网卡状态
## ip
- `ip addr show` 或 `ip a` 查看全部网络接口和 ip
- `ip link show` 或 `ip link` 查看全部网络接口
- `ip link show ethX`，`ethX` 为网络接口名，查看某个具体的网络接口
- `ifconfig` 也可查看

`ip` 命令看到网卡的状态中有 `UP` 即表示网卡状态正常
```bash
root@ubuntu22 netplan $ ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:e7:c8:8e brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    altname ens33
```

## ethtool 
- `ethtool 网卡设备名` 查看网卡状态
- 最后一行 `Link detected: yes` 表示正常

```bash
root@ubuntu22 ~ $ ethtool eth0
Settings for eth0:
	Supported ports: [ TP ]
	Supported link modes:   10baseT/Half 10baseT/Full
	                        100baseT/Half 100baseT/Full
	                        1000baseT/Full
	Supported pause frame use: No
	Supports auto-negotiation: Yes
	Supported FEC modes: Not reported
	Advertised link modes:  10baseT/Half 10baseT/Full
	                        100baseT/Half 100baseT/Full
	                        1000baseT/Full
	Advertised pause frame use: No
	Advertised auto-negotiation: Yes
	Advertised FEC modes: Not reported
	Speed: 1000Mb/s
	Duplex: Full
	Auto-negotiation: on
	Port: Twisted Pair
	PHYAD: 0
	Transceiver: internal
	MDI-X: off (auto)
	Supports Wake-on: d
	Wake-on: d
        Current message level: 0x00000007 (7)
                               drv probe link
	Link detected: yes
```

## nmcli  
- 如果没有 nmcli 命令，根据提示安装 `network-manager` 工具
```bash
root@ubuntu22 netplan $ nmcli
Command 'nmcli' not found, but can be installed with:
snap install network-manager  # version 1.2.2-30, or
apt  install network-manager  # version 1.36.6-0ubuntu2
See 'snap info network-manager' for additional versions.

root@ubuntu22 netplan $ apt install -y network-manager 
```

- ubuntu22.04 如果用 `ip a` 看到网卡状态正常，用 `nmcli connection` 看不到网卡状态，
  需要在 `/etc/netplan` 目录下的 `/.yaml` 网卡配置文件中指定 `renderer` 为 `NetworkManager`
  注意配置文件中网卡的名要与 `ip a` 中显示的网卡设备名一致，即 `nmcli connection` 显示的 `DEVICE`

```bash
root@ubuntu22 ~ $ cd /etc/netplan/
root@ubuntu22 netplan $ ls
eth0.yaml

root@ubuntu22 netplan $ nmcli connection show 
NAME          UUID                                  TYPE      DEVICE 
netplan-eth0  626dd384-8b3d-3690-9511-192b2c79b3fd  ethernet  eth0   

root@ubuntu22 netplan $ cat eth0.yaml 
# This is the network config written by 'subiquity'
network:
  ethernets:
    eth0:
      dhcp4: true
  version: 2
  renderer: NetworkManager
```

### nmcli c[onnection] 

```bash
[18:47 lx@ubunut22 ~]$nmcli connection 
NAME                UUID                                  TYPE      DEVICE 
Wired connection 1  a5cf956e-08b4-391a-82fd-53837a505bea  ethernet  ens33  
```

### nmcli device

```bash
root@Rocky8 network-scripts $ nmcli device 
DEVICE  TYPE      STATE                   CONNECTION 
eth0    ethernet  connected               eth0       
virbr0  bridge    connected (externally)  virbr0     
lo      loopback  unmanaged 
```

# 更新网络配置文件
## rocky8.6
### nmcli
> [nmcli](https://networkmanager.dev/docs/api/latest/nmcli.html)
> [RHEL8.x - issue with nmcli con reload](https://access.redhat.com/discussions/6303851)

- nmcli con down NAME && nmcli reload && nmcli con up NAME
`NAME` 为网卡配置文件中的 `NAME`，也是 `nmcli con show` 中显示的第一列内容：
```bash
root@Rocky8 ~ $ nmcli connection show
NAME    UUID                                  TYPE      DEVICE
eth0    7fb201c8-1ad7-4ad5-9e94-44ac4fa4faa8  ethernet  eth0
virbr0  7c38bb24-d2c0-4a03-bc3c-939ffc9dcd92  bridge    virbr0
```

在`nmcli connection`命令中，`reload`、`reapply`和`up`是三个不同的子命令，用于管理和配置网络连接。它们的具体区别如下：
1. `reload`子命令：
   - 作用：重新加载 NetworkManager 的配置文件以更新网络连接的状态。
   - 使用场景：当对 NetworkManager 的配置文件（`/etc/NetworkManager/`目录下的文件）进行修改后，可以使用`reload`命令使修改生效并重新加载配置。
   - 示例：`nmcli connection reload`

2. `reapply`子命令：
   - 作用：在不重启网络连接的情况下，重新应用当前连接配置。
   - 使用场景：当需要更改当前连接的一些属性时，可以使用`reapply`命令重新应用这些更改，而无需断开和重新连接网络。
   - 示例：`nmcli connection reapply <connection-name>`

3. `up`子命令：
   - 作用：启用或激活指定的网络连接。
   - 使用场景：当需要手动启动一个配置好但当前处于禁用状态的网络连接时，可以使用`up`命令来激活该连接。
   - 示例：`nmcli connection up <connection-name>`

综上所述，`reload`命令用于重新加载 NetworkManager 的配置文件，`reapply`命令用于重新应用当前连接的配置，
而`up`命令用于激活指定的网络连接。这些命令在管理和配置网络连接时提供了不同的功能和用途。

## ubuntu22.04
### netplan 
> [Network configuration](https://ubuntu.com/server/docs/network-configuration)
> [Netplan static IP on Ubuntu configuration](https://linuxconfig.org/how-to-configure-static-ip-address-on-ubuntu-18-04-bionic-beaver-linux)


- `netplan apply`

### nmcli
需要按照包，管理和 rocky8.6 中一样

# 网卡命名规则
> [Linux Network Interface Naming](https://leo.leung.xyz/wiki/Linux_Network_Interface_Naming)
> [Consistent Network Device Naming](https://en.wikipedia.org/wiki/Consistent_Network_Device_Naming)
> [Network interface naming](https://library.netapp.com/ecmdocs/ECMP1155586/html/GUID-60DA02FA-B824-4B4E-862F-6862D1407453.html)
> [NetworkInterfaceNames](https://wiki.debian.org/NetworkInterfaceNames)


## 传统的网卡命名规则
- 传统的网卡命名统一叫 `ethX`，`X`为编号，如 `eth0`，`eth1` 等
- 编号根据启动时内核识别的顺序命名
- CentOS 6 之前版本采用

缺点：
- 如果机器上有多个网卡，一旦移除已存在的网卡或者新增网卡，
  则已存在的旧网卡名可能变化，可能造成安全隐患，如不便于防火墙制定规则管理


## 新网卡命名规则 Predictable Network Naming
- 根据硬件位置对网卡命名

命名规则：
1. 前缀
- en
ethernet
- wl
wireless LAN
- ww
wireless wide area network

2. 后缀  
- oN
onboard device, where N is the onboard index
- sN
hot plug, where N is the slot index
- xMAC
based on MAC address
- pN/sX
devices connected on a bus, where N is the bus number and X is the slot number


示例：
- `eno0` is the first onboard ethnet device
- `wlp2s1` is a wireless device located at a PCI bus 2, slot 1

# 修改新命名规则为旧命名规则
> [Linux: Disable assignment of new styled names for network interfaces](https://michlstechblog.info/blog/linux-disable-assignment-of-new-names-for-network-interfaces/)
 

- 编辑 `/etc/default/grub` 文件，在变量 `GRUB_CMDLINE_LINUX`的值中添加两个内核参数 `net.ifnames=0 biosdevname=0`

## ubuntu22.04

`ip a` 或者 `ip link` 查看初始网卡名为 ens33：
```bash
root@ubuntu22 init.d $ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:0c:29:e7:c8:8e brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    inet 10.0.0.157/24 metric 100 brd 10.0.0.255 scope global dynamic ens33
       valid_lft 921sec preferred_lft 921sec
    inet6 fe80::20c:29ff:fee7:c88e/64 scope link 
       valid_lft forever preferred_lft forever
```

1. 修改 /etc/default/grub 配置文件
```bash
root@ubuntu22 init.d $ vim /etc/default/grub

# If you change this file, run 'update-grub' afterwards to update
# /boot/grub/grub.cfg.
# For full documentation of the options in this file, see:
#   info -f grub -n 'Simple configuration'

GRUB_DEFAULT=0
GRUB_TIMEOUT_STYLE=hidden
GRUB_TIMEOUT=0
GRUB_DISTRIBUTOR=`lsb_release -i -s 2> /dev/null || echo Debian`
GRUB_CMDLINE_LINUX_DEFAULT=""
#GRUB_CMDLINE_LINUX="" #默认该变量为空

# 新增两个内核参数
GRUB_CMDLINE_LINUX="net.ifnames=0 biosdevname=0" 
```

2. 更新 /boot/grub/grub.cfg
测试系统为 BIOS 引导方式

- 方法一：执行 update-grub 命令更新 /boot/grub/grub.cfg
```bash
root@ubuntu22 init.d $ update-grub
Sourcing file `/etc/default/grub'
Sourcing file `/etc/default/grub.d/init-select.cfg'
Generating grub configuration file ...
Found linux image: /boot/vmlinuz-5.15.0-69-generic
Found initrd image: /boot/initrd.img-5.15.0-69-generic
Found linux image: /boot/vmlinuz-5.15.0-67-generic
Found initrd image: /boot/initrd.img-5.15.0-67-generic
Warning: os-prober will not be executed to detect other bootable partitions.
Systems on them will not be added to the GRUB boot configuration.
Check GRUB_DISABLE_OS_PROBER documentation entry.
done
```

- 方法二： 执行命令 `grub-mkconfig -o /boot/grub/grub.cfg` 
结果和上面方法相同

3. 修改网卡配置文件
- 需要在 `/etc/netplan` 目录下的 `.yaml` 网卡配置文件中的网卡名改为新的网卡名
- 可以将网卡配置名字改为新网卡名，如 `eth0.yaml`
- 让网卡配置文件生效 `netplan apply`

4. reboot
此时用 `ip a` 或 `ip link` 可看到网卡名已修改，变为 `eth0`
```bash
root@ubuntu22 ~ $ ip link 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:e7:c8:8e brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    altname ens33
```


## rocky 8.6
1. 修改 /etc/default/grub 配置文件
同 ubuntu 22.04 

2. 更新 grub.cfg 配置文件
- BIOS 引导
```bash
grub2-mkconfig -o /boot/grub2/grub.cfg
```
- UEFI 引导
```bash
grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg
```

3. 修改网卡配置文件中的网卡配置文件名和配置文件中的 DEVICE 名
- 配置文件在 `/etc/sysconfig/network-scripts/` 目录中
- 每个网卡的配置，包括 IP 地址等有一个单独的配置文件
- 配置文件的命名格式固定，前缀为 `ifcfg-`，后缀为网卡的设备名，即该配置文件中 `DEVICE` 变量的值
将配置文件名的后缀改为旧命名方式的新网卡名，并修改该配置文件中的 `DEVICE` 为新网卡名

4. 重启

# 虚拟机中添加一块新网卡
环境：虚拟机（VMware）

1. 添加网卡
VMware ---> 虚拟机 ---> 设置，在虚拟机设置界面添加网卡，选择一种网络连接模式

2. 配置新网卡
`ip a` 可以看到新网卡名，但没 ip 等信息，需要在配置文件中配置

- ubuntu22.04
   - 进入 `/etc/netplan` 目录下，可以看到有一个初始网卡配置的 `.yaml` 配置文件
   - 可以在原来的配置文件中添加新的网卡配置，或者重新建立一个 `.yaml` 配置文件
   - `netplan apply` 让网卡配置文件生效 

- rocky8
	- 进入 `/etc/sysconfig/network-scripts/` 目录，可看到有 `ifcfg-` 开头的文件名 
	- 在该目录下新建网卡配置文件，如 `ifcfg-eth1`，网卡名为 `eth1`
   - 让新网卡配置文件生效
      - `nmcli connection reload`
      - `nmmcli connection up NAME`
      `NAME` 为网卡配置文件中定义的 `NAME`
      - `nmcli connection` 查看生效的网卡，绿色为正常状态

3. 查看新网卡 ip
- `ip a`


# 修改网卡 ip

## ubuntu22.04
> [Netplan network configuration tutorial for beginners](https://linuxconfig.org/netplan-network-configuration-tutorial-for-beginners)

如修改 ip 为 `10.0.0.201`

1. 修改 `/etc/netplan` 目录下的 `.yaml` 网卡配置文件中的 `addresses`
```bash
    # This file describes the network interfaces available on your system
  1 # For more information, see netplan(5).
  2 network:
  3   version: 2
  4  #renderer: networkd
  5   renderer: NetworkManager
  6   ethernets:
  7     eth0:
  8       match:
  9         name: eth0
 10       addresses:
 11       - 10.0.0.201/24
 12      #gateway4: 10.0.0.2
 13       routes:
 14       - to: default
 15         via: 10.0.0.2
```

2. netplan apply 使其生效
```bash
[root@ubuntu22-c1 ~]$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:0c:29:98:e3:96 brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    altname ens33
    inet 10.0.0.201/24 brd 10.0.0.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe98:e396/64 scope link
       valid_lft forever preferred_lft forever
```
## rocky8.6
> [Understanding the Network interface configuration file /etc/sysconfig/network-scripts/ifcfg-eth#](https://www.thegeekdiary.com/understanding-the-network-interface-configuration-file-etc-sysconfig-network-scripts-ifcfg-eth/)
> [11.2. Interface Configuration Files](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/s1-networkscripts-interfaces)
> [Understanding the Network interface configuration file /etc/sysconfig/network-scripts/ifcfg-eth#](https://www.thegeekdiary.com/understanding-the-network-interface-configuration-file-etc-sysconfig-network-scripts-ifcfg-eth/)
> [Chapter 13. Network Scripts](https://mirror.apps.cam.ac.uk/pub/doc/redhat/redhat7.3/rhl-rg-en-7.3/ch-networkscripts.html)
> 查看网络配置参数：[nm-settings-ifcfg-rh](https://developer-old.gnome.org/NetworkManager/stable/nm-settings-ifcfg-rh.html)


### 查看默认网络参数
- `ip a` 查看 IP 地址，子网掩码，广播地址等
```bash
[root@rocky8-1 network-scripts]$ ip addr show eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:54:b6:1a brd ff:ff:ff:ff:ff:ff
    altname enp3s0
    altname ens160
    inet 10.0.0.162/24 brd 10.0.0.255 scope global dynamic noprefixroute eth0
       valid_lft 1467sec preferred_lft 1467sec
    inet6 fe80::20c:29ff:fe54:b61a/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```

1. 上面 IPv4 地址为 `10.0.0.162`
2. PREFIX 为 24，即子网掩码为 `255.255.255.0`

- `route -n` 查看默认路由
```bash
[root@rocky8-1 network-scripts]$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.0.0.2        0.0.0.0         UG    100    0        0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0
```
上面可看到默认路由为 `10.0.0.2`


### 修改配置文件的参数
- 配置文件在 `/etc/sysconfig/network-scripts/` 目录中
- 每个网卡的配置，包括 IP 地址等有一个单独的配置文件
- 配置文件的命名格式固定，前缀为 `ifcfg-`，后缀为网卡的设备名，即该配置文件中 `DEVICE` 变量的值

```bash
[root@rocky8-1 ~]$ cd /etc/sysconfig/network-scripts/
[root@rocky8-1 network-scripts]$ ls
ifcfg-ens160
[root@rocky8-1 network-scripts]$ mv ifcfg-ens160 ifcfg-eth0
[root@rocky8-1 network-scripts]$ vim ifcfg-eth0
```

- 如网卡配置文件 `ifcfg-eth0`：
```bash
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=none
DEFROUTE=yes
IPADDR=10.0.0.82
PREFIX=24
GATEWAY=10.0.0.2
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
NAME=eth0
UUID=26fbfd70-8518-4b0d-a0bc-69669c59622a
DEVICE=eth0
ONBOOT=yes
```
- `DEVICE` 为网卡的设备名 
- `NAME` 为这个网卡整个配置的名字，用 `nmcli` 操作该网卡时使用的名字，`man nmcli` 查看帮助
- `NAME` 可以和 `DEVICE` 不同
- `DEVICE` 的名字必须和网卡配置文件名字的后缀相同
- BOOTPROTO
    - 地址配置协议，默认 dhcp
    - 自定义 ip 需要修改为 none 或 static
- IPADDR
    - 指明 IP 地址，默认没有，由 DHCP 自动分配
    - 如果配置多个 IP，则第二个 IP 用 `IPADDR2`
- PREFIX 
    - 指定子网掩码位数，和 `NETMASK` 作用相同
    - 如 24 则子网掩码为 `255.255.255.0`
- GATEWAY
    - 默认网关
    - 可用 `route -n` 查看，`Destination` 为 `0.0.0.0` 对应的 `Gateway` 即为默认网关
- IPV4_FAILURE_FATAL
    - no
    This interface is not disabled if configuration fails
    - yes
    This interface is disabled if IPv4 or IPv6 configuration failes

### 让新网卡配置文件生效
修改网卡配置文件后保存，并不能让配置立刻生效

- `nmcli connection down NAME`
`NAME` 为网卡配置文件中定义的 `NAME`
- `nmcli connection reload`
- `nmmcli connection up NAME`

```bash
[root@rocky8-1 network-scripts]$ nmcli connection down eth0
Connection 'eth0' successfully deactivated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/2)


[root@rocky8-1 network-scripts]$ nmcli connection 
NAME    UUID                                  TYPE      DEVICE 
virbr0  9eac4062-fdc2-4208-9aba-f053addb47bc  bridge    virbr0 
eth0    26fbfd70-8518-4b0d-a0bc-69669c59622a  ethernet  --     


[root@rocky8-1 network-scripts]$ nmcli connection reload 

[root@rocky8-1 network-scripts]$ nmcli connection up eth0
Connection successfully activated (D-Bus active path: /org/freedesktop/NetworkManager/ActiveConnection/3)
```

检查新的 IP 是否生效
```bash
[root@rocky8-1 network-scripts]$ nmcli connection 
NAME    UUID                                  TYPE      DEVICE 
eth0    26fbfd70-8518-4b0d-a0bc-69669c59622a  ethernet  eth0   
virbr0  9eac4062-fdc2-4208-9aba-f053addb47bc  bridge    virbr0 

[root@rocky8-1 network-scripts]$ ip addr show eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:54:b6:1a brd ff:ff:ff:ff:ff:ff
    altname enp3s0
    altname ens160
    inet 10.0.0.82/24 brd 10.0.0.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe54:b61a/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```


# 查看默认网关 
## 虚拟机中查看
如果用虚拟机安装系统，在装系统时会有一个网卡，如选择的网卡模式为 NAT，在 **虚拟机 --> 设置** 可以查看选择的网卡模式：
![](img/2023-09-07-21-00-41.png)
在 **编辑 --> 虚拟网络编辑器 --> NAT设置** 可以查看或修改默认网关的 IP 地址，如果不能修改，则点击 **虚拟网络编辑器** 右下角的更改设置：
![](img/2023-09-07-21-01-35.png)

## 命令查看
### ip r[oute]
- `ip r` 或 `ip route`

### route -n
- `route -n` 
- 下面命令查询可见默认网关为 `10.0.0.2`，主机 IP 为 `10.0.0.157`

```bash
root@ubuntu22 netplan $ ip r
default via 10.0.0.2 dev eth0 proto dhcp src 10.0.0.157 metric 100 
10.0.0.0/24 dev eth0 proto kernel scope link src 10.0.0.157 metric 100 
10.0.0.2 dev eth0 proto dhcp scope link src 10.0.0.157 metric 100 
root@ubuntu22 netplan $ 
root@ubuntu22 netplan $ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.0.0.2        0.0.0.0         UG    100    0        0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0
10.0.0.2        0.0.0.0         255.255.255.255 UH    100    0        0 eth0
```

# 多网卡 bonding


# 检查域名解析
## host
- 默认使用的 DNS 服务器为 /etc/resolv.conf 文件中定义的服务器
- 可以用 `server` 选项指定其他的域名服务器

```bash
[root@rocky8-3 ~]$ whatis host
host (1)             - DNS lookup utility
[root@rocky8-3 ~]$
[root@rocky8-3 ~]$ host --help
host: illegal option -- -
Usage: host [-aCdilrTvVw] [-c class] [-N ndots] [-t type] [-W time]
            [-R number] [-m flag] hostname [server]
       -a is equivalent to -v -t ANY
       -c specifies query class for non-IN data
       -C compares SOA records on authoritative nameservers
       -d is equivalent to -v
       -i IP6.INT reverse lookups
       -l lists all hosts in a domain, using AXFR
       -m set memory debugging flag (trace|record|usage)
       -N changes the number of dots allowed before root lookup is done
       -p specifies the port on the server to query
       -r disables recursive processing
       -R specifies number of retries for UDP packets
       -s a SERVFAIL response should stop query
       -t specifies the query type
       -T enables TCP/IP mode
       -U enables UDP mode
       -v enables verbose output
       -V print version number and exit
       -w specifies to wait forever for a reply
       -W specifies how long to wait for a reply
       -4 use IPv4 query transport only
       -6 use IPv6 query transport only
```

```bash
[root@centos7 ~]# host www.github.com
www.github.com is an alias for github.com.
github.com has address 20.205.243.166
github.com mail is handled by 1 aspmx.l.google.com.
github.com mail is handled by 5 alt1.aspmx.l.google.com.
github.com mail is handled by 5 alt2.aspmx.l.google.com.
github.com mail is handled by 10 alt3.aspmx.l.google.com.
github.com mail is handled by 10 alt4.aspmx.l.google.com.
```

```bash
[root@centos7 ~]# host www.github.com 183.60.82.98
Using domain server:
Name: 183.60.82.98
Address: 183.60.82.98#53
Aliases:

www.github.com is an alias for github.com.
github.com has address 20.205.243.166
github.com mail is handled by 1 aspmx.l.google.com.
github.com mail is handled by 5 alt1.aspmx.l.google.com.
github.com mail is handled by 5 alt2.aspmx.l.google.com.
github.com mail is handled by 10 alt3.aspmx.l.google.com.
github.com mail is handled by 10 alt4.aspmx.l.google.com.
```

## nslookup
- 默认使用的 DNS 服务器为 /etc/resolv.conf 文件中定义的服务器

```bash
[root@rocky8-3 ~]$ nslookup www.github.com
Server:         10.0.0.2
Address:        10.0.0.2#53

Non-authoritative answer:
www.github.com  canonical name = github.com.
Name:   github.com
Address: 20.205.243.166
```

## dig

## whois 查询域名注册信息

## cname 查询别名
# 查看 DNS 服务器地址
## rocky8.6
- `/etc/resolv.conf`

```bash
[root@Rocky8 network-scripts]# cat /etc/resolv.conf 
# Generated by NetworkManager
search localdomain 6
nameserver 10.0.0.2
```

## ubuntu 22.04
- `/etc/resolv.conf`

```bash
[20:42 lx@ubunut22 ~]$cat /etc/resolv.conf 
# This is /run/systemd/resolve/stub-resolv.conf managed by man:systemd-resolved(8).
# Do not edit.
#
# This file might be symlinked as /etc/resolv.conf. If you're looking at
# /etc/resolv.conf and seeing this text, you have followed the symlink.
#
# This is a dynamic resolv.conf file for connecting local clients to the
# internal DNS stub resolver of systemd-resolved. This file lists all
# configured search domains.
#
# Run "resolvectl status" to see details about the uplink DNS servers
# currently in use.
#
# Third party programs should typically not access this file directly, but only
# through the symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a
# different way, replace this symlink by a static file or a different symlink.
#
# See man:systemd-resolved.service(8) for details about the supported modes of
# operation for /etc/resolv.conf.

nameserver 127.0.0.53
options edns0 trust-ad
search .
```
根据提示运行 `resolvectl status` 查看

# 添加域名解析服务器地址
## Rocky8.6
- 修改 `/etc/sysconfig/network-scripts/ifcfg-eth0` 配置文件，其中 `eth0` 为网卡名
- 添加 `DNS1=10.0.0.2`，`DNS2=服务器地址` 
- 让配置生效
	- `nmcli connection reload`
	- `nmcli connection up eth1`，其中 `eth1` 不是网卡名，而是配置文件中写的 `NAME`
- `cat /etc/resolv.conf` 查看
- 判断域名解析是否生效
	- host
	- nslookup

## Ubuntu22.04
- 修改 `/etc/netplan` 目录下的 `.yaml` 网卡配置文件，添加 `nameservers`
```bash
network:
  version: 2
 #renderer: networkd
  renderer: NetworkManager
  ethernets:
    eth0:
      match:
        name: eth0
      addresses:
      - 10.0.0.201/24
      routes:
      - to: default
        via: 10.0.0.2
      nameservers:
         addresses: [10.0.0.2]
```

- netplan apply 使其生效
- 判断域名解析是否生效
	- host
	- nslookup


# route 查看和操作路由表
- 最好用 ip 命令代替
- 命令中设置的参数等都是临时生效

```bash
[root@rocky8-2 init.d]$ route --help
Usage: route [-nNvee] [-FC] [<AF>]           List kernel routing tables
       route [-v] [-FC] {add|del|flush} ...  Modify routing table for AF.

       route {-h|--help} [<AF>]              Detailed usage syntax for specified AF.
       route {-V|--version}                  Display version/author and exit.

        -v, --verbose            be verbose
        -n, --numeric            don't resolve names
        -e, --extend             display other/more information
        -F, --fib                display Forwarding Information Base (default)
        -C, --cache              display routing cache instead of FIB

  <AF>=Use -4, -6, '-A <af>' or '--<af>'; default: inet
  List of possible address families (which support routing):
    inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25)
    netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP)
    x25 (CCITT X.25)
```

## route -n 查看路由状态
- `-n` 表示不解析名字，直接用 ip 或端口号

```bash
[root@rocky8-2 init.d]$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.0.0.2        0.0.0.0         UG    100    0        0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0
[root@rocky8-2 init.d]$
[root@rocky8-2 init.d]$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default         _gateway        0.0.0.0         UG    100    0        0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0
```

- Flags 说明
```bash
Flags  Possible flags include
              U (route is up)
              H (target is a host)
              G (use gateway)
              R (reinstate route for dynamic routing)
              D (dynamically installed by daemon or redirect)
              M (modified from routing daemon or redirect)
              A (installed by addrconf)
              C (cache entry)
              !  (reject route)
```

## route add 增加路由

## route del 删除路由

## zeroconf route
> [CentOS / RHEL: Remove Routes 169.254.0.0 / 255.255.0.0 From the System](https://www.cyberciti.biz/faq/fedora-centos-rhel-linux-disable-zeroconf-route-169-254-0-0/)


- 在 centos7 上查看路由表时，可以看到一个地址为 `169.254.0.0` 的路由记录
```bash
[root@centos7 ~]$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.0.8.1        0.0.0.0         UG    0      0        0 eth0
10.0.8.0        0.0.0.0         255.255.252.0   U     0      0        0 eth0
169.254.0.0     0.0.0.0         255.255.0.0     U     1002   0        0 eth0
```

- 禁用 zeroconf
编辑 `/etc/sysconfig/network` 文件，添加 `NOZEROCONF=yes`
重启网络服务 `systemctl restart NetworkManager.service`，但仍不生效，重启后生效


# ip 网络参数综合操作
```bash
[root@rocky8-2 init.d]$ whatis ip
ip (7)               - Linux IPv4 protocol implementation
ip (8)               - show / manipulate routing, network devices, interfaces and tunnels
```

## 命令格式
```bash
[root@rocky8-2 init.d]$ ip --help
Usage: ip [ OPTIONS ] OBJECT { COMMAND | help }
       ip [ -force ] -batch filename
where  OBJECT := { address | addrlabel | amt | fou | help | ila | ioam | l2tp |
                   link | macsec | maddress | monitor | mptcp | mroute | mrule |
                   neighbor | neighbour | netconf | netns | nexthop | ntable |
                   ntbl | route | rule | sr | tap | tcpmetrics |
                   token | tunnel | tuntap | vrf | xfrm }
       OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |
                    -h[uman-readable] | -iec | -j[son] | -p[retty] |
                    -f[amily] { inet | inet6 | mpls | bridge | link } |
                    -4 | -6 | -M | -B | -0 |
                    -l[oops] { maximum-addr-flush-attempts } | -br[ief] |
                    -o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] |
                    -rc[vbuf] [size] | -n[etns] name | -N[umeric] | -a[ll] |
                    -c[olor]}
```
- `OPTIONS` 可选，选项
- `OBJECT`，表示命令对象
  - `link` 对象针对物理链路层的操作，如 MTU，MAC等
  - `address` IP 层的操作
  - `route` 路由相关设置
- `COMMAND` 命令 可选

命令中设置的参数等都是临时生效

## link 链路层接口设备相关
`ip link help | less` 查看相关命令帮助
### ip -s link show 查看全部网络接口信息
- `-s` 选项可以显示详细的统计信息
```bash
[root@rocky8-2 ~]$ ip -s link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    RX:  bytes packets errors dropped  missed   mcast
          5012      32      0       0       0       0
    TX:  bytes packets errors dropped carrier collsns
          5012      32      0       0       0       0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:5c:56:b0 brd ff:ff:ff:ff:ff:ff
    RX:  bytes packets errors dropped  missed   mcast
        297522    2663      0       0       0     166
    TX:  bytes packets errors dropped carrier collsns
        239833    1969      0       0       0       0
    altname enp3s0
    altname ens160
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1000
    link/ether 52:54:00:cb:9e:93 brd ff:ff:ff:ff:ff:ff
    RX:  bytes packets errors dropped  missed   mcast
             0       0      0       0       0       0
    TX:  bytes packets errors dropped carrier collsns
             0       0      0       0       0       0
```
```bash
[root@rocky8-2 ~]$ ip link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:5c:56:b0 brd ff:ff:ff:ff:ff:ff
    altname enp3s0
    altname ens160
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default qlen 1000
    link/ether 52:54:00:cb:9e:93 brd ff:ff:ff:ff:ff:ff
```

- `lo` 为 `loopback` 环回测试网络接口
- `eth0` 为网卡名称
- `RX` 为网络由启动到目前为止接收的数据包信息
- `TX` 为网络由启动到目前为止发送的数据包信息


### ip link set DEVNAME up 启动网络接口
- 临时生效
- DEVNAME 为网络接口设备名，如 eth0

### ip link set DEVNAME down 禁用网络接口
- 临时生效
- DEVNAME 为网络接口设备名，如 eth0
- 如果远程做改操作，则网络接口无法重启，因为网络会断开

### ip link set DEVNAME mtu NUM 设置 MTU 值
- 临时生效
- DEVNAME 为网络接口设备名，如 eth0
- NUM 为 MTU 数值，如 1000

### ip link set DEVNAME name 修改网卡名
- 临时生效
- DEVNAME 为网络接口设备名，如 eth0
- 设置前先关闭网络接口
- 需要 root 权限

1. 初始网卡名为 ens33，网卡 IP 为 10.0.0.151
```bash
[lx@ubunut22:~]$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:0c:29:c7:51:cb brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    inet 10.0.0.151/24 brd 10.0.0.255 scope global dynamic noprefixroute ens33
       valid_lft 1099sec preferred_lft 1099sec
    inet6 fe80::e2c5:7e1b:9fc5:8ba3/64 scope link noprefixroute 
       valid_lft forever preferred_lft forever
```
2. 禁用网卡
- 需要 root 权限
- 禁用后 `ip link` 查看网卡状态没有 `UP`
```bash
[lx@ubunut22:~]$ ip link set ens33 down
RTNETLINK answers: Operation not permitted
[lx@ubunut22:~]$ su -
[root@ubunut22:~]$ ip link set ens33 down
[root@ubunut22:~]$ ip link 
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: ens33: <BROADCAST,MULTICAST> mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:c7:51:cb brd ff:ff:ff:ff:ff:ff
    altname enp2s1
[root@ubunut22:~]$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
    link/ether 00:0c:29:c7:51:cb brd ff:ff:ff:ff:ff:ff
    altname enp2s1
```
3. 修改网卡名为 `eth0`
- 修改完后改网卡无 IP 地址
```bash
[root@ubunut22:~]$ ip link set ens33 name eth0
[root@ubunut22:~]$ 
[root@ubunut22:~]$ ip link
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc fq_codel state DOWN mode DEFAULT group default qlen 1000
    link/ether 00:0c:29:c7:51:cb brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    altname ens33
[root@ubunut22:~]$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
    link/ether 00:0c:29:c7:51:cb brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    altname ens33
```
4. 启动网卡
```bash
[root@ubunut22:~]$ ip link set eth0 up
[root@ubunut22:~]$ ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:0c:29:c7:51:cb brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    altname ens33
```
5. 为新网卡名设置 IP 地址
- 原来的网卡的 IP 地址为 `10.0.0.151`
- 新的 IP 地址设置为 `10.0.0.21/24`，和原来的 IP 同网段
- ping 同网段的其他虚拟机可以通信，ping 外部网络失败
```bash
[root@ubunut22:~]$ ip address add 10.0.0.21/24 dev eth0
[root@ubunut22:~]$ ip addr show eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:0c:29:c7:51:cb brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    altname ens33
    inet 10.0.0.21/24 scope global eth0
       valid_lft forever preferred_lft forever
[root@ubunut22:~]$ 
[root@ubunut22:~]$ ping 10.0.0.82
PING 10.0.0.82 (10.0.0.82) 56(84) bytes of data.
64 bytes from 10.0.0.82: icmp_seq=1 ttl=64 time=0.901 ms
64 bytes from 10.0.0.82: icmp_seq=2 ttl=64 time=0.460 ms
64 bytes from 10.0.0.82: icmp_seq=3 ttl=64 time=0.810 ms
^C
--- 10.0.0.82 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2013ms
rtt min/avg/max/mdev = 0.460/0.723/0.901/0.190 ms
[root@ubunut22:~]$ ping www.baidu.com
ping: www.baidu.com: Temporary failure in name resolution
```
6. 增加默认网关
- 无法与外部网络通信，查询路由表发现无默认网关
```bash
[root@ubunut22:~]$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
[root@ubunut22:~]$ 
```

- 增加默认网关后可以通过 IP 与外部网络通信，但域名无法解析
1) 增加默认网关
```bash
[root@ubunut22:~]$ ip route add default via 10.0.0.2 dev eth0
[root@ubunut22:~]$ ip route show
default via 10.0.0.2 dev eth0 
10.0.0.0/24 dev eth0 proto kernel scope link src 10.0.0.21 
[root@ubunut22:~]$ 
[root@ubunut22:~]$ ip a show eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
    link/ether 00:0c:29:c7:51:cb brd ff:ff:ff:ff:ff:ff
    altname enp2s1
    altname ens33
    inet 10.0.0.21/24 scope global eth0
       valid_lft forever preferred_lft forever
[root@ubunut22:~]$ 
[root@ubunut22:~]$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.0.0.2        0.0.0.0         UG    0      0        0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U     0      0        0 eth0
```

2) 通过外部网络 IP 地址测试网络是否连通
先在其他主机查询 IP 地址
```bash
[17:04:15 root@ubuntu2004 ~]#host www.baidu.com
www.baidu.com is an alias for www.a.shifen.com.
www.a.shifen.com has address 220.181.38.149
www.a.shifen.com has address 220.181.38.150
Host www.a.shifen.com not found: 3(NXDOMAIN)
Host www.a.shifen.com not found: 3(NXDOMAIN)
```

本机上测试，IP 可以通信，域名无法解析
```bash
[root@ubunut22:~]$ ping 220.181.38.150
PING 220.181.38.150 (220.181.38.150) 56(84) bytes of data.
64 bytes from 220.181.38.150: icmp_seq=1 ttl=128 time=4.61 ms
64 bytes from 220.181.38.150: icmp_seq=2 ttl=128 time=4.95 ms
64 bytes from 220.181.38.150: icmp_seq=3 ttl=128 time=5.41 ms
^C
--- 220.181.38.150 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2003ms
rtt min/avg/max/mdev = 4.614/4.992/5.412/0.327 ms
```

```bash
[root@ubunut22:~]$ ping www.baidu.com
ping: www.baidu.com: Temporary failure in name resolution
[root@ubunut22:~]$ 
[root@ubunut22:~]$ host www.baidu.com
Host www.baidu.com not found: 2(SERVFAIL)
```

7. dhclient 修复域名解析问题
- 查看域名解析配置文件
```bash
[root@ubunut22:~]$ cat /etc/resolv.conf 
# This is /run/systemd/resolve/stub-resolv.conf managed by man:systemd-resolved(8).
# Do not edit.
#
# This file might be symlinked as /etc/resolv.conf. If you're looking at
# /etc/resolv.conf and seeing this text, you have followed the symlink.
#
# This is a dynamic resolv.conf file for connecting local clients to the
# internal DNS stub resolver of systemd-resolved. This file lists all
# configured search domains.
#
# Run "resolvectl status" to see details about the uplink DNS servers
# currently in use.
#
# Third party programs should typically not access this file directly, but only
# through the symlink at /etc/resolv.conf. To manage man:resolv.conf(5) in a
# different way, replace this symlink by a static file or a different symlink.
#
# See man:systemd-resolved.service(8) for details about the supported modes of
# operation for /etc/resolv.conf.

nameserver 127.0.0.53
options edns0 trust-ad
search .
```
- 查看域名解析服务状态
```bash
[root@ubunut22:~]$ resolvectl status 
Global
       Protocols: -LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
resolv.conf mode: stub

Link 2 (eth0)
Current Scopes: none
     Protocols: -DefaultRoute +LLMNR -mDNS -DNSOverTLS DNSSEC=no/unsupported
```
没有域名解析服务器，需要配置域名解析服务器

```bash
[root@ubunut22:~]$ systemctl status systemd-resolved.service 
● systemd-resolved.service - Network Name Resolution
     Loaded: loaded (/lib/systemd/system/systemd-resolved.service; enabled; vendor preset: enabled)
     Active: active (running) since Sat 2023-04-29 17:00:02 CST; 16min ago
       Docs: man:systemd-resolved.service(8)
             man:org.freedesktop.resolve1(5)
             https://www.freedesktop.org/wiki/Software/systemd/writing-network-configuration-managers
             https://www.freedesktop.org/wiki/Software/systemd/writing-resolver-clients
   Main PID: 249176 (systemd-resolve)
     Status: "Processing requests..."
      Tasks: 1 (limit: 4573)
     Memory: 5.6M
        CPU: 96ms
     CGroup: /system.slice/systemd-resolved.service
             └─249176 /lib/systemd/systemd-resolved

4月 29 17:00:01 ubunut22 systemd[1]: Starting Network Name Resolution...
4月 29 17:00:02 ubunut22 systemd-resolved[249176]: Positive Trust Anchors:
4月 29 17:00:02 ubunut22 systemd-resolved[249176]: . IN DS 20326 8 2 e06d44b80b8f1d39a95c0b0d7c65d0845>
4月 29 17:00:02 ubunut22 systemd-resolved[249176]: Negative trust anchors: home.arpa 10.in-addr.arpa 1>
4月 29 17:00:02 ubunut22 systemd-resolved[249176]: Using system hostname 'ubunut22'.
4月 29 17:00:02 ubunut22 systemd[1]: Started Network Name Resolution.
```


- 手动修改 `/etc/resolv.conf` 文件配置 dns server
从上面可以看见没有 dns server，因此手动修改配置文件中的 `nameserver` 的地址
如改为网关地址 `10.0.0.2`，重新测试，可以 ping 通外网

## address 网络层 IP 相关设置
- `ip link help | less` 查看相关命令帮助
- `man 8 ip-address` 查看详细帮助

```bash
[root@ubunut22:~]$ ip address help
Usage: ip address {add|change|replace} IFADDR dev IFNAME [ LIFETIME ]
                                                      [ CONFFLAG-LIST ]
       ip address del IFADDR dev IFNAME [mngtmpaddr]
       ip address {save|flush} [ dev IFNAME ] [ scope SCOPE-ID ]
                            [ to PREFIX ] [ FLAG-LIST ] [ label LABEL ] [up]
       ip address [ show [ dev IFNAME ] [ scope SCOPE-ID ] [ master DEVICE ]
                         [ type TYPE ] [ to PREFIX ] [ FLAG-LIST ]
                         [ label LABEL ] [up] [ vrf NAME ] ]
       ip address {showdump|restore}
IFADDR := PREFIX | ADDR peer PREFIX
          [ broadcast ADDR ] [ anycast ADDR ]
          [ label IFNAME ] [ scope SCOPE-ID ] [ metric METRIC ]
SCOPE-ID := [ host | link | global | NUMBER ]
FLAG-LIST := [ FLAG-LIST ] FLAG
FLAG  := [ permanent | dynamic | secondary | primary |
           [-]tentative | [-]deprecated | [-]dadfailed | temporary |
           CONFFLAG-LIST ]
CONFFLAG-LIST := [ CONFFLAG-LIST ] CONFFLAG
CONFFLAG  := [ home | nodad | mngtmpaddr | noprefixroute | autojoin ]
LIFETIME := [ valid_lft LFT ] [ preferred_lft LFT ]
LFT := forever | SECONDS
TYPE := { bareudp | bond | bond_slave | bridge | bridge_slave |
          dummy | erspan | geneve | gre | gretap | ifb |
          ip6erspan | ip6gre | ip6gretap | ip6tnl |
          ipip | ipoib | ipvlan | ipvtap |
          macsec | macvlan | macvtap |
          netdevsim | nlmon | rmnet | sit | team | team_slave |
          vcan | veth | vlan | vrf | vti | vxcan | vxlan | wwan |
          xfrm }
```

### ip address show 显示全部网络接口的 IP 参数
```bash
[root@rocky8-2 ~]$ ip address show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:5c:56:b0 brd ff:ff:ff:ff:ff:ff
    altname enp3s0
    altname ens160
    inet 10.0.0.82/24 brd 10.0.0.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe5c:56b0/64 scope link noprefixroute
       valid_lft forever preferred_lft forever
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN group default qlen 1000
    link/ether 52:54:00:cb:9e:93 brd ff:ff:ff:ff:ff:ff
    inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever
```

### ip address add 为一个网卡添加新的网络接口
- 一个网卡添加新的网络接口，该网络接口设置新的 IP 地址
- 注意添加多个 IP 最好加上 `label` 

```bash
[root@rocky8-3 ~]# ip address show eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:98:2a:21 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.83/24 brd 10.0.0.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe98:2a21/64 scope link
       valid_lft forever preferred_lft forever
```

```bash
[root@rocky8-3 ~]# ip address add 10.0.0.84/24 dev eth0 label eth0:1
[root@rocky8-3 ~]#
[root@rocky8-3 ~]# ip address show eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:98:2a:21 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.83/24 brd 10.0.0.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet 10.0.0.84/24 scope global secondary eth0:1
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe98:2a21/64 scope link
       valid_lft forever preferred_lft forever
```

### ip address del 删除网络接口
```bash
[root@rocky8-3 ~]# ip address show eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:98:2a:21 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.83/24 brd 10.0.0.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet 10.0.0.84/24 scope global secondary eth0:1
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe98:2a21/64 scope link
       valid_lft forever preferred_lft forever
```
```bash
[root@rocky8-3 ~]# ip address del 10.0.0.84/24 dev eth0
```
```bash
[root@rocky8-3 ~]# ip address show eth0
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 00:0c:29:98:2a:21 brd ff:ff:ff:ff:ff:ff
    inet 10.0.0.83/24 brd 10.0.0.255 scope global noprefixroute eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fe98:2a21/64 scope link
       valid_lft forever preferred_lft forever
```

### ip address flush 清除网卡上全部 IP
- `man ip-address` 查看帮助

```bash
ip address flush dev eth4 scope global
    Removes all global IPv4 and IPv6 addresses from device eth4. 
    Without 'scope global' it would remove all addresses including IPv6 link-local ones.
```

## ip route 路由相关设置
- `man 8 ip-route` 查看帮助文档
- `ip route help` 查看简单帮助

### ip route show 查看当前路由信息
- proto 指路由的路由协议，`kernel` 表示由内核判断自动设置
- scope 指路由的范围 
  - `SCOPE := [ host | link | global | NUMBER ]`
  - scope `link` for direct unicast and broadcast routes
  - scope 为 `link` 表示与本设备有关的直接连接

```bash
[root@rocky8-3 ~]# ip route show
default via 10.0.0.2 dev eth0 proto static metric 100
10.0.0.0/24 dev eth0 proto kernel scope link src 10.0.0.83 metric 100
192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 linkdown
[root@rocky8-3 ~]#
[root@rocky8-3 ~]# route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         10.0.0.2        0.0.0.0         UG    100    0        0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U     100    0        0 eth0
192.168.122.0   0.0.0.0         255.255.255.0   U     0      0        0 virbr0
```

### ip route add 添加路由
> [How To Add Route on Linux](https://devconnected.com/how-to-add-route-on-linux/)

- ip route add <network_ip>/<cidr> via <gateway_ip> dev <network_card_name>
#### 添加默认路由
- ip route add default via GW dev IFACE
```bash
ip route add default via 10.0.0.2 dev eth0
```
### ip route del 删除路由
- ip route del TARGET

# 无线网络操作命令
## iwlist
```bash
[18:44:29 root@ubuntu2004 ~]#iwlist
Usage: iwlist [interface] scanning [essid NNN] [last]
              [interface] frequency
              [interface] channel
              [interface] bitrate
              [interface] rate
              [interface] encryption
              [interface] keys
              [interface] power
              [interface] txpower
              [interface] retry
              [interface] ap
              [interface] accesspoints
              [interface] peers
              [interface] event
              [interface] auth
              [interface] wpakeys
              [interface] genie
              [interface] modulation
[18:44:32 root@ubuntu2004 ~]#
```

## iwconfig
```bash
[18:44:32 root@ubuntu2004 ~]#iwconfig
lo        no wireless extensions.

wlp1s0    IEEE 802.11  ESSID:"LAPTOP-VB238NKA 9364"
          Mode:Managed  Frequency:5.805 GHz  Access Point: 7E:B5:66:5F:41:AA
          Bit Rate=866.7 Mb/s   Tx-Power=22 dBm
          Retry short limit:7   RTS thr:off   Fragment thr:off
          Encryption key:off
          Power Management:on
          Link Quality=70/70  Signal level=-38 dBm
          Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0
          Tx excessive retries:1  Invalid misc:35   Missed beacon:0
```

# DHCP 客户端命令
## dhclient 
用 `dhclient eth0` 可以不用修改配置文件而让网卡以 DHCP 协议尝试获取 ip


# 网络排错与查看命令
## ping 测试两台主机的两点沟通
- 发送 ICMP 数据包探测两个主机能否通信
```bash
[root@rocky8-2 ~]$ whatis ping
ping (8)             - send ICMP ECHO_REQUEST to network hosts
```
### ping -c NUM 指定执行 ping 的次数
- count，指定执行次数，不指一直发送，需要 ctrl-c 终止
- 最前面的 `64 bytes` 表示发送的 ICMP 数据包的大小为 64字节，默认值
```bash
[root@rocky8-2 ~]$ ping -c 5 www.baidu.com
PING www.a.shifen.com (220.181.38.150) 56(84) bytes of data.
64 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=1 ttl=128 time=4.52 ms
64 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=2 ttl=128 time=4.44 ms
64 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=3 ttl=128 time=4.57 ms
64 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=4 ttl=128 time=3.92 ms
64 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=5 ttl=128 time=4.02 ms

--- www.a.shifen.com ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4006ms
rtt min/avg/max/mdev = 3.923/4.293/4.565/0.267 ms
```

### ping -t 指定 TTL 数值
- 如果检测主机与本主机不在一个网络，则默认 255
- 检测主机与本主机在一个网络，则默认 64

```bash
[root@rocky8-2 ~]$ ping -c5 10.0.0.83
PING 10.0.0.83 (10.0.0.83) 56(84) bytes of data.
64 bytes from 10.0.0.83: icmp_seq=1 ttl=64 time=0.498 ms
64 bytes from 10.0.0.83: icmp_seq=2 ttl=64 time=0.317 ms
64 bytes from 10.0.0.83: icmp_seq=3 ttl=64 time=0.415 ms
64 bytes from 10.0.0.83: icmp_seq=4 ttl=64 time=0.748 ms
64 bytes from 10.0.0.83: icmp_seq=5 ttl=64 time=0.467 ms

--- 10.0.0.83 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4085ms
rtt min/avg/max/mdev = 0.317/0.489/0.748/0.143 ms
```

### ping -s 发送 ICMP 数据包的大小
- 默认 56 bytes，还要加上 8 字节的 ICMP 头部，总共 64 字节
- 注意 ICMP 数据包是在 IP 数据包中，还要加上 IP 数据包的包头，至少 20 字节

```bash
-s packetsize
  Specifies the number of data bytes to be sent. 
  The default is 56, which translates into 64 ICMP data bytes 
  when combined with the 8 bytes of ICMP header data.
```

### ping -M 检测网络 MTU 数值的大小
- do 传送 `DF（Don't Fragment）` 标识，禁止分片
- dont 不传送 `DF` 标识，允许分片
- 默认以太网 MTU 为 1500
- 注意 ICMP 数据包是在 IP 数据包中，还要加上 IP 数据包的包头，至少 20 字节
  ICMP 数据包的包头还有 8 字节
  实际指定 ICMP 数据包的数据部分大小最大为 1500-20-8=1472
- 本地网卡的 MTU 也影响检测，以太网接口默认设置 1500

```bash
[root@rocky8-2 ~]$ ping -c 2 -s 1470 -M do www.baidu.com
PING www.baidu.com (220.181.38.149) 1470(1498) bytes of data.

--- www.baidu.com ping statistics ---
2 packets transmitted, 0 received, 100% packet loss, time 1060ms

[root@rocky8-2 ~]$ ping -c 2 -s 1300 -M do www.baidu.com
PING www.a.shifen.com (220.181.38.150) 1300(1328) bytes of data.
1308 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=1 ttl=128 time=6.14 ms
1308 bytes from 220.181.38.150 (220.181.38.150): icmp_seq=2 ttl=128 time=6.75 ms

--- www.a.shifen.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 6.137/6.445/6.753/0.308 ms
```

```bash
 -M pmtudisc_opt
           Select Path MTU Discovery strategy.  
           pmtudisc_option may be either do (prohibit fragmentation, even local one), 
           want (do PMTU discovery, fragment locally when packet size is large), 
           or dont (do not set DF flag).
```

### ping -W 等待相应的秒数
- Time to wait for a response, in seconds.

## mtr 网络诊断工具
```bash
[root@rocky8-3 ~]$ whatis mtr
mtr (8)              - a network diagnostic tool
```

## traceroute 检测两主机在网络中的各节点
- rocky8 默认未安装，需要手动安装 

### -n 不进行域名解析，用 IP

### -U 使用 UDP 的特定端口
```bash
Use UDP to particular destination port for tracerouting (instead of increasing the port per each probe). 
Default port is 53 (dns).
```

### -I 使用 ICMP 的方式检测

### -T 时使用 TCP 检测
```bash
Use TCP SYN for probes
```

### -w 指定等待响应的最大时间
- 默认 5 秒

### -p 指定检测的端口号
```bash
For UDP tracing, specifies the destination port base traceroute will use 
(the destination port number will be incremented by each probe).

For ICMP tracing, specifies the initial ICMP sequence value (incremented by each probe too).
For TCP and others specifies just the (constant) destination port to connect.
```

### -i 指定发送数据包的接口
```bash
Specifies the interface through which traceroute should send packets. 
By default, the interface is selected according to the routing table.
```

### -g 指定路由

# 检查本机网络的连接
- 如果网络服务已启动但无法连接，可以检查网络接口的监听端口是否已启动

## netstat
> [NETSTAT Command Explained](https://www.youtube.com/watch?v=8UZFpCQeXnM&ab_channel=PowerCertAnimatedVideos)

- 比较通用，windows 中也可以使用
- linux 中可以用 ss 代替，ss 信息更详细，更快

### -r 列出路由表信息
- 和 route 相同
- 加上 `-n` 参数，相当于 `route -n`，不进行域名解析

```bash
[root@rocky8-2 ~]$ netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
default         _gateway        0.0.0.0         UG        0 0          0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U         0 0          0 eth0
192.168.122.0   0.0.0.0         255.255.255.0   U         0 0          0 virbr0
[root@rocky8-2 ~]$
[root@rocky8-2 ~]$ netstat -rn
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
0.0.0.0         10.0.0.2        0.0.0.0         UG        0 0          0 eth0
10.0.0.0        0.0.0.0         255.255.255.0   U         0 0          0 eth0
192.168.122.0   0.0.0.0         255.255.255.0   U         0 0          0 virbr0
```

### -c 设置几秒后自动更新
- 设置几秒后刷新，即持续检测
```bash
 -c, --continuous
       This will cause netstat to print the selected information every second continuously.
```

## ss
> [A Comparison Between ss vs netstat Commands](https://tecadmin.net/comparison-between-ss-vs-netstat-commands/)

- 代替 netstat，比 netstat 更快
```bash
[root@rocky8-2 ~]$ time netstat -antp

...

real    0m0.031s
user    0m0.006s
sys     0m0.024s


[root@rocky8-2 ~]$ time ss -antp

...

real    0m0.026s
user    0m0.010s
sys     0m0.016s
```


### -n 不解析服务名称，用 IP 和 端口号代替
- `--numeric`

### -r 解析主机名
- `--resolve`

### -a 显示所有数据
- Display both listening and non-listening (for TCP this means established connections) sockets.

### -l 列出已在监听的连接
- `--listening`

### -t 列出 TCP 数据包的连接
- `--tcp`

### -u 列出 UDP 数据包的连接
- `--udp`

### -p 列出对应的进程
- `--process`

### -m 显示连接内存的使用情况
```bash
-m, --memory
  Show socket memory usage. The output format is:
```

### -f 指定过滤类型
- 如只看 IPv4 地址用 `ss -f inet`

```bash
-f FAMILY, --family=FAMILY
  Display sockets of type FAMILY.  Currently the following families are supported:
  unix, inet, inet6, link, netlink, vsock, xdp.
```

```bash
[root@rocky8-2 ~]$ ss -ntlp -f inet| tr -s '[[:blank:]]' '\t'
State   Recv-Q  Send-Q  Local   Address:Port    Peer    Address:PortProcess
LISTEN  0       32      192.168.122.1:53        0.0.0.0:*       users:(("dnsmasq",pid=1934,fd=6))
LISTEN  0       128     0.0.0.0:22      0.0.0.0:*       users:(("sshd",pid=1016,fd=3))
LISTEN  0       5       127.0.0.1:631   0.0.0.0:*       users:(("cupsd",pid=1260,fd=7))
LISTEN  0       128     127.0.0.1:6011  0.0.0.0:*       users:(("sshd",pid=9800,fd=13))
LISTEN  0       128     0.0.0.0:111     0.0.0.0:*       users:(("rpcbind",pid=918,fd=4),("systemd",pid=1,fd=35))
```

### -A 指定过滤类型
```bash
-A QUERY, --query=QUERY, --socket=QUERY
  List of socket tables to dump, separated by commas. 
  The following identifiers are understood: all, inet, tcp,  udp,  raw,  
  unix,  packet,  netlink,  unix_dgram, unix_stream, unix_seqpacket, packet_raw, 
  packet_dgram, dccp, sctp, vsock_stream, vsock_dgram, 
  xdp Any item in the list may optionally be prefixed by an exclama‐tion mark 
  (!)  to exclude that socket table from being dumped.
```

# 端口查看工具
## netstat 查看本机自己的端口

## ss 查看本机自己的端口
- netstat 的增强版

## nmap 检测网络其他主机
# 数据包捕获工具
## tcpdump 文字接口数据包捕获
> [10 Useful tcpdump examples on Linux](https://www.howtouselinux.com/post/10-useful-tcpdump-command-examples)

### -D 显示全部可以捕获数据包的网络接口
```bash
[root@rocky8-3 ~]$ tcpdump -D
1.eth0 [Up, Running]
2.lo [Up, Running, Loopback]
3.any (Pseudo-device that captures on all interfaces) [Up, Running]
4.virbr0 [Up]
5.bluetooth-monitor (Bluetooth Linux Monitor) [none]
6.nflog (Linux netfilter log (NFLOG) interface) [none]
7.nfqueue (Linux netfilter queue (NFQUEUE) interface) [none]
8.bluetooth0 (Bluetooth adapter number 0) [none]
9.usbmon0 (Raw USB traffic, all USB buses) [none]
10.usbmon1 (Raw USB traffic, bus number 1)
11.usbmon2 (Raw USB traffi- c, bus number 2)
```

### -c 指定捕获数据包的数量
- 不指定则持续监听

### -nn 以端口及IP显示而非主机名和服务名
- Don't convert protocol and port numbers etc. to names either.


## wireshark 图形接口数据包捕获

## nc 任意启动 TCP/UDP 数据包端口连接
> [nc Command (Netcat) with Examples](https://phoenixnap.com/kb/nc-command)


# 网络连接不上原因排查
> [6.1 无法联机原因分析](http://cn.linux.vbird.org/linux_server/0150detect_network_1.php)
> [6.2 处理流程](http://cn.linux.vbird.org/linux_server/0150detect_network_2.php)